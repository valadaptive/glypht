const _=async r=>{let t,e;if(typeof r=="string")try{t=new URL(r)}catch{e=r}else t=r;if(t)try{t.protocol==="file:"&&(e=(await import("./__vite-browser-external-9wXp6ZBx.js")).fileURLToPath(t))}catch{}if(e){let o;try{o=await import("./__vite-browser-external-9wXp6ZBx.js")}catch{}if(o){const i=await o.readFile(e);return new Uint8Array(i.buffer,i.byteOffset,i.byteLength)}}if(!t)throw new Error(`Your runtime does not support any loading strategy for ${r}.`);return new Uint8Array(await(await fetch(t)).arrayBuffer())},p=async(r,t)=>{if(typeof r=="object"&&"byteLength"in r)return await WebAssembly.instantiate(r,t);if("instantiateStreaming"in WebAssembly){const e=typeof r=="string"?new URL(r):r;if(e.protocol!=="file:"){const o=await fetch(e);return await WebAssembly.instantiateStreaming(o,t)}}return await WebAssembly.instantiate(await _(r),t)},w=async r=>{const t=()=>{throw new Error("Not implemented")},e={fd_seek:t,fd_write:t,fd_close:t,proc_exit:t,emscripten_notify_memory_growth:()=>{l.memoryView=new DataView(s.exports.memory.buffer),l.HEAPU8=new Uint8Array(s.exports.memory.buffer)}},o={env:e,wasi_snapshot_preview1:e},{module:i,instance:s}=await p(r,o),n=s.exports.__indirect_function_table,l={wasmMemory:s.exports.memory,HEAPU8:new Uint8Array(s.exports.memory.buffer),memoryView:new DataView(s.exports.memory.buffer),stackAlloc:s.exports._emscripten_stack_alloc,stackRestore:s.exports._emscripten_stack_restore,stackSave:s.exports.emscripten_stack_get_current,addIndirectFunction(a){const c=n.grow(1);return n.set(c,a),c},withStack(a){const c=s.exports.emscripten_stack_get_current();try{return a()}finally{s.exports._emscripten_stack_restore(c)}},readUint32(a){return this.memoryView.getUint32(a,!0)},writeUint32(a,c){this.memoryView.setUint32(a,c,!0)},readFloat32(a){return this.memoryView.getFloat32(a,!0)},writeFloat32(a,c){this.memoryView.setFloat32(a,c,!0)},malloc(a){const c=s.exports.malloc(a);if(c===0)throw new Error("Out of WASM memory");return c}};for(const a of WebAssembly.Module.exports(i))switch(a.name){case"memory":case"_emscripten_stack_alloc":case"_emscripten_stack_restore":case"emscripten_stack_get_current":case"malloc":case"__indirect_function_table":case"_initialize":continue;default:l[`_${a.name}`]=s.exports[a.name];break}return s.exports._initialize(),l},y=(r,t=[])=>{try{postMessage(r,{transfer:t})}catch(e){postMessage({type:"error",message:e,originId:r.originId})}};let f=null,m=null;const d=async r=>{const t=r.data;try{switch(t.type){case"init-woff-wasm":{f=w(t.message.woff1),m=w(t.message.woff2);break}case"compress-font":{let e;switch(t.message.algorithm){case"woff":e=await g(t.message.data,t.message.quality);break;case"woff2":e=await b(t.message.data,t.message.quality);break}y({type:"compressed-font",message:e,originId:t.id},[e.buffer]);break}case"decompress-font":{let e;switch(t.message.algorithm){case"woff":e=await h(t.message.data);break;case"woff2":e=await k(t.message.data);break}y({type:"decompressed-font",message:e,originId:t.id},[e.buffer]);break}case"close":removeEventListener("message",d)}}catch(e){postMessage({type:"error",message:e,originId:t.id})}};addEventListener("message",d);const u=["","Out of memory","Invalid input file","Compression failure","Bad signature","Buffer too small","Bad parameter","Improperly ordered chunks"],g=async(r,t)=>{if(!f)throw new Error("WOFF1 module not initialized");const e=await f,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{return e.withStack(()=>{const i=e.stackAlloc(4),s=e.stackAlloc(4),n=e._woffEncode(o,r.byteLength,0,0,t,i,s);if(!n)throw new Error("Failed to convert TTF to WOFF");const l=e.readUint32(s);if((l&255)!==0)throw new Error(`Failed to convert TTF to WOFF: ${u[l]}`);const a=e.HEAPU8.slice(n,n+e.readUint32(i));return e._free(n),a})}finally{e._free(o)}},h=async r=>{if(!f)throw new Error("WOFF1 module not initialized");const t=await f,e=t.malloc(r.byteLength);t.HEAPU8.set(r,e);try{return t.withStack(()=>{const o=t.stackAlloc(4),i=t.stackAlloc(4),s=t._woffDecode(e,r.byteLength,o,i);if(!s)throw new Error("Failed to convert WOFF to TTF");const n=t.readUint32(i);if((n&255)!==0)throw new Error(`Failed to convert WOFF to TTF: ${u[n]}`);const l=t.HEAPU8.slice(s,s+t.readUint32(o));return t._free(s),l})}finally{t._free(e)}},b=async(r,t)=>{if(!m)throw new Error("WOFF2 module not initialized");const e=await m,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{const i=e._max_woff2_compressed_size(o,r.byteLength),s=e.malloc(i);try{return e.withStack(()=>{const n=e.stackAlloc(4);if(e.writeUint32(n,i),!!!e._convert_ttf_to_woff2(o,r.byteLength,s,n,t))throw new Error("Failed to convert TTF to WOFF2");return e.HEAPU8.slice(s,s+e.readUint32(n))})}finally{e._free(s)}}finally{e._free(o)}},k=async r=>{if(!m)throw new Error("WOFF2 module not initialized");const e=await m,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{const i=e._compute_woff2_final_size(o,r.byteLength);let s=e.malloc(i);try{return e.withStack(()=>{const n=e.stackAlloc(4);return s=e._convert_woff2_to_ttf(o,r.byteLength,n,62914560),e.HEAPU8.slice(s,s+e.readUint32(n))})}finally{e._free(s)}}finally{e._free(o)}};
