const p=async r=>{let t,e;if(typeof r=="string")try{t=new URL(r)}catch{e=r}else t=r;if(t)try{t.protocol==="file:"&&(e=(await import("./__vite-browser-external-9wXp6ZBx.js")).fileURLToPath(t))}catch{}if(e){let o;try{o=await import("./__vite-browser-external-9wXp6ZBx.js")}catch{}if(o){const i=await o.readFile(e);return new Uint8Array(i.buffer,i.byteOffset,i.byteLength)}}if(!t)throw new Error(`Your runtime does not support any loading strategy for ${r}.`);return new Uint8Array(await(await fetch(t)).arrayBuffer())},g=async(r,t)=>{if(typeof r=="object"&&"byteLength"in r)return await WebAssembly.instantiate(r,t);if("instantiateStreaming"in WebAssembly){const e=typeof r=="string"?new URL(r):r;if(e.protocol!=="file:"){const o=await fetch(e);return await WebAssembly.instantiateStreaming(o,t)}}return await WebAssembly.instantiate(await p(r),t)},d=async r=>{const t=()=>{throw new Error("Not implemented")};let e;const o={fd_seek:t,fd_write:t,fd_close:t,proc_exit:t,emscripten_notify_memory_growth:()=>{e=new DataView(s.exports.memory.buffer),f.HEAPU8=new Uint8Array(s.exports.memory.buffer)}},i={env:o,wasi_snapshot_preview1:o},{module:a,instance:s}=await g(r,i);e=new DataView(s.exports.memory.buffer);const l=s.exports.__indirect_function_table,f={wasmMemory:s.exports.memory,HEAPU8:new Uint8Array(s.exports.memory.buffer),stackAlloc:s.exports._emscripten_stack_alloc,stackRestore:s.exports._emscripten_stack_restore,stackSave:s.exports.emscripten_stack_get_current,addIndirectFunction(n){const c=l.grow(1);return l.set(c,n),c},withStack(n){const c=s.exports.emscripten_stack_get_current();try{return n()}finally{s.exports._emscripten_stack_restore(c)}},readUint32(n){return e.getUint32(n,!0)},writeUint32(n,c){e.setUint32(n,c,!0)},readFloat32(n){return e.getFloat32(n,!0)},writeFloat32(n,c){e.setFloat32(n,c,!0)},malloc(n){const c=s.exports.malloc(n);if(c===0)throw new Error("Out of WASM memory");return c}};for(const n of WebAssembly.Module.exports(a))switch(n.name){case"memory":case"_emscripten_stack_alloc":case"_emscripten_stack_restore":case"emscripten_stack_get_current":case"malloc":case"__indirect_function_table":case"_initialize":continue;default:f[`_${n.name}`]=s.exports[n.name];break}return s.exports._initialize(),f},u=(r,t=[])=>{try{postMessage(r,void 0,t)}catch(e){postMessage({type:"error",message:e,originId:r.originId})}};let m=null,w=null;const y=async r=>{const t=r.data;try{switch(t.type){case"init-woff-wasm":{m=d(t.message.woff1),w=d(t.message.woff2);break}case"compress-font":{let e;switch(t.message.algorithm){case"woff":e=await b(t.message.data,t.message.quality);break;case"woff2":e=await k(t.message.data,t.message.quality);break}u({type:"compressed-font",message:e,originId:t.id},[e.buffer]);break}case"decompress-font":{let e;switch(t.message.algorithm){case"woff":e=await h(t.message.data);break;case"woff2":e=await E(t.message.data);break}u({type:"decompressed-font",message:e,originId:t.id},[e.buffer]);break}case"close":removeEventListener("message",y)}}catch(e){postMessage({type:"error",message:e,originId:t.id})}};addEventListener("message",y);const _=["","Out of memory","Invalid input file","Compression failure","Bad signature","Buffer too small","Bad parameter","Improperly ordered chunks"],b=async(r,t)=>{if(!m)throw new Error("WOFF1 module not initialized");const e=await m,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{return e.withStack(()=>{const i=e.stackAlloc(4),a=e.stackAlloc(4),s=e._woffEncode(o,r.byteLength,0,0,t,i,a);if(!s)throw new Error("Failed to convert TTF to WOFF");const l=e.readUint32(a);if((l&255)!==0)throw new Error(`Failed to convert TTF to WOFF: ${_[l]}`);const f=e.HEAPU8.slice(s,s+e.readUint32(i));return e._free(s),f})}finally{e._free(o)}},h=async r=>{if(!m)throw new Error("WOFF1 module not initialized");const t=await m,e=t.malloc(r.byteLength);t.HEAPU8.set(r,e);try{return t.withStack(()=>{const o=t.stackAlloc(4),i=t.stackAlloc(4),a=t._woffDecode(e,r.byteLength,o,i);if(!a)throw new Error("Failed to convert WOFF to TTF");const s=t.readUint32(i);if((s&255)!==0)throw new Error(`Failed to convert WOFF to TTF: ${_[s]}`);const l=t.HEAPU8.slice(a,a+t.readUint32(o));return t._free(a),l})}finally{t._free(e)}},k=async(r,t)=>{if(!w)throw new Error("WOFF2 module not initialized");const e=await w,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{const i=e._max_woff2_compressed_size(o,r.byteLength),a=e.malloc(i);try{return e.withStack(()=>{const s=e.stackAlloc(4);if(e.writeUint32(s,i),!!!e._convert_ttf_to_woff2(o,r.byteLength,a,s,t))throw new Error("Failed to convert TTF to WOFF2");return e.HEAPU8.slice(a,a+e.readUint32(s))})}finally{e._free(a)}}finally{e._free(o)}},E=async r=>{if(!w)throw new Error("WOFF2 module not initialized");const e=await w,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{const i=e._compute_woff2_final_size(o,r.byteLength);let a=e.malloc(i);try{return e.withStack(()=>{const s=e.stackAlloc(4);return a=e._convert_woff2_to_ttf(o,r.byteLength,s,62914560),e.HEAPU8.slice(a,a+e.readUint32(s))})}finally{e._free(a)}}finally{e._free(o)}};
