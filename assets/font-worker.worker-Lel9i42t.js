const fetchFile = async (path) => {
  let pathUrl, filePath;
  if (typeof path === "string") {
    try {
      pathUrl = new URL(path);
    } catch {
      filePath = path;
    }
  } else {
    pathUrl = path;
  }
  if (pathUrl) {
    try {
      if (pathUrl.protocol === "file:") {
        filePath = (await import("./__vite-browser-external-Dhvy_jtL.js")).fileURLToPath(pathUrl);
      }
    } catch {
    }
  }
  if (filePath) {
    let fsp;
    try {
      fsp = await import("./__vite-browser-external-Dhvy_jtL.js");
    } catch {
    }
    if (fsp) {
      const buf = await fsp.readFile(filePath);
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
  }
  if (!pathUrl) {
    throw new Error(`Your runtime does not support any loading strategy for ${path}.`);
  }
  return new Uint8Array(await (await fetch(pathUrl)).arrayBuffer());
};
const instantiateWasm = async (path, imports) => {
  if (typeof path === "object" && "byteLength" in path) {
    return await WebAssembly.instantiate(path, imports);
  }
  if ("instantiateStreaming" in WebAssembly) {
    const pathUrl = typeof path === "string" ? new URL(path) : path;
    if (pathUrl.protocol !== "file:") {
      const response = await fetch(pathUrl);
      return await WebAssembly.instantiateStreaming(response, imports);
    }
  }
  return await WebAssembly.instantiate(await fetchFile(path), imports);
};
const initWasm = async (source) => {
  const stub = () => {
    throw new Error("Not implemented");
  };
  const importFns = {
    fd_seek: stub,
    fd_write: stub,
    fd_close: stub,
    proc_exit: stub,
    emscripten_notify_memory_growth: () => {
      augmentedModule.memoryView = new DataView(instance.exports.memory.buffer);
      augmentedModule.HEAPU8 = new Uint8Array(instance.exports.memory.buffer);
    }
  };
  const imports = {
    env: importFns,
    wasi_snapshot_preview1: importFns
  };
  const { module, instance } = await instantiateWasm(source, imports);
  const funcTable = instance.exports.__indirect_function_table;
  const augmentedModule = {
    wasmMemory: instance.exports.memory,
    HEAPU8: new Uint8Array(instance.exports.memory.buffer),
    memoryView: new DataView(instance.exports.memory.buffer),
    stackAlloc: instance.exports._emscripten_stack_alloc,
    stackRestore: instance.exports._emscripten_stack_restore,
    stackSave: instance.exports.emscripten_stack_get_current,
    addIndirectFunction(f) {
      const addr = funcTable.grow(1);
      funcTable.set(addr, f);
      return addr;
    },
    withStack(f) {
      const stack = instance.exports.emscripten_stack_get_current();
      try {
        return f();
      } finally {
        instance.exports._emscripten_stack_restore(stack);
      }
    },
    readUint32(addr) {
      return this.memoryView.getUint32(addr, true);
    },
    writeUint32(addr, value) {
      this.memoryView.setUint32(addr, value, true);
    },
    readFloat32(addr) {
      return this.memoryView.getFloat32(addr, true);
    },
    writeFloat32(addr, value) {
      this.memoryView.setFloat32(addr, value, true);
    },
    malloc(size) {
      const ptr = instance.exports.malloc(size);
      if (ptr === 0)
        throw new Error("Out of WASM memory");
      return ptr;
    }
  };
  for (const exported of WebAssembly.Module.exports(module)) {
    switch (exported.name) {
      case "memory":
      case "_emscripten_stack_alloc":
      case "_emscripten_stack_restore":
      case "emscripten_stack_get_current":
      case "malloc":
      case "__indirect_function_table":
      case "_initialize":
        continue;
      default:
        augmentedModule[`_${exported.name}`] = instance.exports[exported.name];
        break;
    }
  }
  instance.exports._initialize();
  return augmentedModule;
};
const postMessageFromWorker = (message, transfer = []) => {
  try {
    postMessage(message, void 0, transfer);
  } catch (error) {
    postMessage({ type: "error", message: error, originId: message.originId });
  }
};
const createHarfbuzzWrapped = async (hbWasmUrl) => {
  const hb2 = await initWasm(hbWasmUrl);
  const freeBlob = hb2.addIndirectFunction(hb2._free);
  class HbBlob {
    _ptr;
    constructor(ptrOrData) {
      if (typeof ptrOrData === "number") {
        this._ptr = ptrOrData;
        return;
      }
      const dataPtr = hb2.malloc(ptrOrData.byteLength);
      hb2.HEAPU8.set(ptrOrData, dataPtr);
      const blobPtr = hb2._hb_blob_create_or_fail(dataPtr, ptrOrData.byteLength, 2, dataPtr, freeBlob);
      if (blobPtr === 0) {
        throw new Error("Failed to create blob");
      }
      this._ptr = blobPtr;
    }
    ptr() {
      return this._ptr;
    }
    destroy() {
      hb2._hb_blob_destroy(this._ptr);
    }
    data() {
      return hb2._hb_blob_get_data(this._ptr, this.length());
    }
    length() {
      return hb2._hb_blob_get_length(this._ptr);
    }
    asArray() {
      return hb2.withStack(() => {
        const lengthPtr = hb2.stackAlloc(4);
        const dataPtr = hb2._hb_blob_get_data(this._ptr, lengthPtr);
        const length = hb2.readUint32(lengthPtr);
        return hb2.HEAPU8.subarray(dataPtr, dataPtr + length);
      });
    }
    copyAsArray() {
      return this.asArray().slice();
    }
  }
  class HbSet {
    _ptr;
    constructor(ptr) {
      if (ptr === 0) {
        throw new Error("Tried to create an HbSet from a null pointer");
      }
      this._ptr = ptr ?? hb2._hb_set_create();
    }
    ptr() {
      return this._ptr;
    }
    add(item) {
      hb2._hb_set_add(this._ptr, item);
    }
    addRange(start, end) {
      hb2._hb_set_add_range(this._ptr, start, end);
    }
    del(item) {
      hb2._hb_set_del(this._ptr, item);
    }
    delRange(start, end) {
      hb2._hb_set_del_range(this._ptr, start, end);
    }
    clear() {
      hb2._hb_set_clear(this._ptr);
    }
    invert() {
      hb2._hb_set_invert(this._ptr);
    }
    reference() {
      hb2._hb_set_reference(this._ptr);
    }
    destroy() {
      if (this._ptr === 0) {
        throw new Error("Set already destroyed");
      }
      hb2._hb_set_destroy(this._ptr);
      this._ptr = 0;
    }
    union(other) {
      hb2._hb_set_union(this._ptr, other._ptr);
    }
    intersect(other) {
      hb2._hb_set_intersect(this._ptr, other._ptr);
    }
    subtract(other) {
      hb2._hb_set_subtract(this._ptr, other._ptr);
    }
    size() {
      return hb2._hb_set_get_population(this._ptr);
    }
    copy() {
      const newPtr = hb2._hb_set_copy(this._ptr);
      if (newPtr === 0) {
        throw new Error("Failed to copy set");
      }
      return new HbSet(newPtr);
    }
    setTo(other) {
      hb2._hb_set_set(this._ptr, other._ptr);
    }
    [Symbol.iterator]() {
      const ptr = this._ptr;
      return (function* () {
        const iter = new HbSetRangeIterator(ptr);
        for (const range of iter) {
          if (typeof range === "number") {
            yield range;
          } else {
            for (let i = range[0], end = range[1]; i <= end; i++) {
              yield i;
            }
          }
        }
      })();
    }
    iterRanges() {
      return new HbSetRangeIterator(this._ptr);
    }
  }
  class HbSetRangeIterator {
    _ptr;
    _last;
    constructor(ptr) {
      this._ptr = ptr;
      this._last = -1 >>> 0;
    }
    next() {
      return hb2.withStack(() => {
        const firstPtr = hb2.stackAlloc(4);
        const lastPtr = hb2.stackAlloc(4);
        hb2.writeUint32(lastPtr, this._last);
        const didIterate = !!hb2._hb_set_next_range(this._ptr, firstPtr, lastPtr);
        const first = hb2.readUint32(firstPtr);
        const last = hb2.readUint32(lastPtr);
        if (didIterate) {
          this._last = last;
          return { done: false, value: first === last ? first : [first, last] };
        }
        return { done: true, value: void 0 };
      });
    }
    [Symbol.iterator]() {
      return this;
    }
  }
  const wrappedMain = hb2;
  wrappedMain.HbBlob = HbBlob;
  wrappedMain.HbSet = HbSet;
  return wrappedMain;
};
const hbTag = (s) => {
  return (s.charCodeAt(0) & 255) << 24 | (s.charCodeAt(1) & 255) << 16 | (s.charCodeAt(2) & 255) << 8 | (s.charCodeAt(3) & 255) << 0;
};
const tagName = (tag) => {
  return String.fromCharCode(tag >> 24 & 255, tag >> 16 & 255, tag >> 8 & 255, tag >> 0 & 255);
};
const SUBSET_RANGES = {
  "adlam": "GicPNQZDBEECShYgyBVCp2cCCwYRAgwUEwEWFvoVuSEBMv/qDUuhAQkdAQ==",
  "ahom": "GiaAAtiUAenEBxo7DicW",
  "anatolian-hieroglyphs": "GiaAAtZ9648JxgQ=",
  "arabic": "GiaAAsEV/wGhBS/BBB5BAQ9KmQEc01wCCQF+5DeftAZyhwK8A/8GNXpDD4ECBA2GAdURG4EuHsUBAnUDifwGAwsaOQEGBgUJFwMKBA4KBAQFAgkBBgYEBAQEBQEGBwMLBhEDCwMKBQkXEC0CCQQNEIsBAQ==",
  "armenian": "GiYa5gHQCdMIJVExaQKGaijQFo/VBgQ=",
  "avestan": "GiYc5AEuq30ByTgBofMGNXMG",
  "balinese": "GiAGPsIBwWlMnQEx+xICghc=",
  "bamum": "GiaAAoGYBVfBhQa4BA==",
  "bassa-vah": "GiaAAtiUAYmUCh1BBQ==",
  "batak": "GiaAAsFsM3kDnxACghc=",
  "bengali": "GiaAArgIqxoBJwE5AwsHFQEJFS8GEAkDDQgXAQkDGAsBBwQPGNRLBAcBBhISBgoHAq0MAtwCphTKjAQ=",
  "bhaiksuki": "GiaAAtd9AoIX6dgHCBUsXQ0xHA==",
  "brahmi": "GiaAAtd9AoIX6agHTaUBI1o=",
  "braille": "GiaAAsGdAf8B",
  "buginese": "GiaAAsFlGz0B2xcCgheGkAQ=",
  "buhid": "GiaAAqtaARcTlyMCghc=",
  "canadian-aboriginal": "GiaAAqICrAYjA17zQ/8E4RJFuDTJ0wcP",
  "carian": "GiaAAi7GfgaoN9/RBjA=",
  "caucasian-albanian": "GiaAAsgJWlrciQGp4QYPoRwzfg==",
  "chakma": "GiaAAo0lCbUZCZc/AoIX6awHNG0R",
  "cham": "GicCDwILAx0BCsIBGr19Agr4FumQBDaBAQ0hCRkD",
  "cherokee": "GiaAAsEJAggPATEBGwHhQVWxAQXx3QRP",
  "chinese-hongkong": "GiaAAsG9AQMKBxMrAQjJAyr3cwEGCQQNAQcBCQIJAQ0BEAsCCQEGDQEHAQ8BBgYGBQILAQgFAQkDGwEUFggIBAcBBgcEEAQHAQcFDgcDEA4NAQcBBwEJAQYPBRMCDQIKEAQJAgoEBAQRAQkEEAcBCgoMDwEKBAQEBQEOBQMMBQQNAgkJFwEOBgcBCAUCCwIJAQsBBgQGBAQECwIKBCMCDQMSBAcCDAUHGwEGBwQeBQgUBAgEBgYGBQIIBQEGBAUCCAYFAgoFBRgQDgkCCgUBDwEGBAQTAQ4MBQMSBwEKEAcBEQIVAQgNAQ0BBgQJAQYIBggNAg0BChYEDQEIBwEKBQEKBAQEBQEGDgUBCA4EEhALAQcCCwIJBhECDgQGBgQIBAYFAgkDDAkDDggOBQEIBAUBCAQSBAUBDAQIDQINARAEBAcCDwEVAQkCIQEGBgUCCwEHAQYHAggIBwEMDAQLAQkCDAQNAgkBDgQIBQYWBAYFAgoRAg0BCAYEBAgECQEJAwwHARUBCwEJAQYHAggeBAYECAQGDAYFAggFAgkBBhgGBAYFAQkBDwEGCgUBDQIICAcBBwEIBgQGBQIQCwUOBQMMCQMMBgUCCQEMDgUCCAQFAggHAQgEKAQGBAwLAQYKEhAEBwMKBggFAQoIBQUPCxoGBwEGBgUBBgUKJgUDDAcDCwMMBAUBBwEHAwoFAQgEBAgMHAQEBQETAggFAQkCCQMKBQELAQYEBQEHAQYECBEHEgQFAQsBBgUFDgUDEQEQEAYEBQURAgoQBQEKBgUBBggFAgoIFgQFAQkGEAQFAQ4LAQYICwENAQ8DCgUDDhIFAg0BBgQFAgoFAgsDDAkCCQEGEQEHAggHBBQMBwMQBAcDCggFAQYEBQEGBQEOBgkBCgQGDAUBCQIKBgUBCwEIBAwECwIIBAUDCggFARAGBAkBCwMTAgkBCQQOBAYEBQEQCgQFAgsCCgQIBhIGDAYGBQEGBgsBDwIKCAYGBwEHBA4GBwEMEwIMCQEJAQgECwEHAQYJAQYICwELAQYFARIFAwwHAQgHBCgGBQQSCAQEBgkBCQERAQYGBg8CDAUBCgYICwIWCQISBg0BEAcCCgUBEgwFAwoEBAQHAgkBEgwKCQEGDAsCCwEWCgYHAg4GBwEGCQEIEgQIBAQICgQGBAkBFAoEBAUBEwMKBAoFAQwGBgkCDAwEBAYIBQEIBAoFAQgVAQcBEwEQBAsCCwEHAQgEBgQFAgkCCA0BDgQIBwIPAw0BBwEGDAQKBgcBDQEGBQEJAQsDEQEIBAcCCQQPAQgFAgoNAgkBCgUCCwEMBAkBBgcEEAQFAQ4FAQYEBAUCDgwIBQIQBQINAg4HAQkCCAQEBAYUBAkBCQELAQkBFwELAQoJAQkCCQEHAQgMBQELAQsBBgQTAQwFAwoGDAYRARAHAQkBEAUBBgoHAggOBQEGBhgLAQgOBwEHAhQECAgEBgwMBAQIDwIIBAsCCwIJBQ8DCgcCDQEHAQsBBwMKBQMKBAQEBQIJAQkBCAQFBRcEFAQEBwYYBgUDEAgFARkBBwEHBQ8BBgQLAQYEDgYHBA0CCAoIBAgFAhAECg0FDwMNAggHBhQIBggEBQEQBgQPARoOCQEIFAYKBgUCDAQJARYKCA0BCAkBHgQHAQYIBAsCDAwOBgYFAQYECgQKBAwKEwEVAQcCCAQMBiAGBwESBg4EBg4MBgQOCAYIFwQNAQoEFAoEBQEPAQkBCQMMBgcDDA0CCwEIBgUBDQEHAggFAQYQDAQMBwIOBgcCCggRAQYQBQITARECCAUBBwMSBgYKDQIKBAgNAQoEDwUTAQkBBgkEFwEGCAYFAQcBFA4HAQcBDAUBBggFAQoHAwsBCAgPAQYICAgECQEWBAQFAhcCDAoFAQYFBA8BBggEBgcCDAUFEwIPAgoEBQERAgkCCggEBQEICwEGDwEHAw8DCgQHAQgNAQ4IDAQFAR8BCAUCCgUCCwEGBQMKCgwZAgoOBgQGCQETAw0FDwEQDwENAQoHARAECAkCCwEKEwEHAggHAhUCCwEOCAYEBAUEEBUEDAcCCAgLAw0DEgkDDAcBCwEIEgYPAQgEBwEJAwoGBAYECwEHAQsBCAYEBgUCEQEJARMBCAUBBwIKBAQQBwIJAQ4JAQYKBAQLBBAIDgoHAQgEDAgHAwoEBQITAQYFAgkCCwEJAgwFAQgJAQoEBQIIBgkEFQIIBQEJAw4GEAUBBgsEDAYHAQYFAggECwEPAwsDJgcBDAgIBwEGBQMLAwsFDwIJBi0DCgUBCAsDCwENAg4GCgQgBQEKBQERAQkBCgcBCAUFFBAOBwIIBQIJAQsBBwIIBQEHAgsCCQEJAQYIBQEGCQQMBQMKBAQhAQcBBgUBCgUBBggJAQ0DEwEJAQ4EBgQXAQ4FAQkBBwEMBAYEBAQGBQETAQYGBQEHAQYdAQYIBAQFARIEDQIIBwYYBgUBDAYFAQYHAgwJAw4FBQ8BCAsBBwEHAQcBBgcBBwELAgwEBgYEBQIMBAcDCgcBBwIIBAwICgoJAQkBBgcDEQIKDgUBBgcBDgYKBAQJBRECCwEIDAwFAQcBFwEGBAoJAQoEBAUBCAQHAQYJAQkBEAQHAQsCCA0BBwEGBgUBGAcBBwEJAwoEDwILAQYJAQcBBgUBCwIKCAcBCAQFAQwEBAcCDA8CDwEJAQYGEAcDCgQEBAYHAgwFAQgIDQEHAgoJAQ0CCAYEBgQIBgUBCAYEBQEGCAoFAw8BEgYHAQgNAQYGCAUCCwIKBQIJAQ0BBwMTAw4FAhMCCQQOBwEMBg4EBQENAwoGDAUCGgQFBAwECgUBBgYGBAQKBQEGBAYFARAXAQkBBwISCgwLBQ8EDQIMBggGBgQFAg0BDBwGBgcBCgwRARoFAQkBCQMLBQ4EBQEHAUYSBAcCCA4JAQgMBQEHAQsBDAUCCAQICAgHAQoEBAoGBQEGCwEICQEOBwEICQIQBAQMBQIKDQEkDAgEBggEBwEICBMBDQEJAQYFAQgEBgUCCgYFAhYIEA0CDQIKBgQFAgoFAQsCCggLAQYRAwoGBQEIEAYICgsBDgQEBAUCEgQKBAkDCgUBBgQKCQEOBAcCCwENAgkBCQEQCwEOBQIIDBIMDAQECwELAgwGBAcBDQELAQoGBQIOBg8BEBMBCgUBCQEOCwESBgQFARQLAQwGCBUBBh4MBAcBEwEGBgQEBAoEBAgFBhIQCwIICAkBBgcBGgQMDA4FAgoGBAYEBwENAQwEBAcCCQILAR8CChYGCgwPAgkBBgYFAQgJAQcCCQIJAgsBCgwFAgwQBAoEBAUGGwIPAQYEBAgHAgkEDQIKBwEHAQgGBCEDDAQLBxIHAQsDCgoEBAgJBAwGBgcDCgQUBAcBDgoECgQEBggHBRIHAgkBBwYSMQIOBwMNAQYFAQYGBwIQBQEIBQIKBAsDDhYKCQEHAQcBBwIKBwEGBQMPAQgFAQoFAgwGBwIJBA0BBgQFAgkDCg0BFhMDCgUCCQMOBQEGBgQIBAQECwEOBwEGDQIKCBAIBwEKLA0BDg0BBgYHAgsBCgQGBAQFAg8BBwEGCQEGBgUCCigGBgQHAQ8BBwEGBAYFAQgJBA4MBQMPAwwFAg4LAgggBgQEBgcBCAQEDwMXAggEBAQEBQIIBwEGCAYMBwEIBgYOBAQIBAYFAyYEBwEGCQIKDwEHAxQECA8BCAQIBAgGBQEGBQIPAhQEGAoTAQkBCgYLAQYHAQwEBgQNAw0BEwELAQkBCAUCCQEQBwQMBQQQCQEGFAgEBAcBBgQEBQIIEBYLAQYECQEQCQEGFgUBBwEJAgwGBQEJAggFAQwGBA0BBgYFAQgJAQYGBA0FDwEGCAUEEQIQDAQFAQcBBgYEDQEHAQwJAQoHAQoKBgUBCwIMBQIJAQsBBwEHAQ0CDQMSCgUBBwEQDQQUChMBDAUCCAsBBwMLARMCDAgEBgUCCQIJAxAEDAYECgQEBwEIEgQGBA4OCgoGHAYEBBQEBAoEDwISHQILAQwRAQwNAQYFAg4GCBYFAwoHAQsCCgwEBAoSEBECCgUBBwIIDAUBBgUBEAcBDAUCDgcDFQEKBAQKBAYGBAYQEgUFEwEJAQwPAQcBCQYRAQgJAQcBBgUDDAYFAggEBAQEBQUQCwIJAQcBCwEQBQIJAwsBCQIKBQIIBQMdAQcBBggEBQIKEQEHAQcCCwEHAxQICggEDggLAQkBDgQIBQIJAQYKBQIIBQIdARAEDgYEBAYFAQkBBwEHAgkEEQEGCAQNAQsCCAkCDQEHAQwHAQsCCwEOBA4PAQkBCgQGCwEJAQ0CDwERAQYHAQkCDAYFAQYGCgUBCQEHAQYEBQIKEwIICwEGBQMSBQIIDAwGBwMKBQEGBggICAQQCQIMBgUBCgQIBgUBBwEKBwIJBBAHAw0BBgUCCgYKBgcBEAgSBAgIBAoHAQcBBgQICAQKBQEHAQYFAggGCQEIBAkBCAQGDwEGBiMBCwEJAQYEBA8CCAQECggPARQFAggHAgkBBgUCEAoEBAUCDwEGCQEGBg4IBQIOBAYFAQcBCBEBCAgICBAIBwMRAQcBCAkCDQEKCgoGBgkBDAQICwEMBQIQBgQFAQcBDA0CEQELAggSDggHAQcBGAQKDQIKBAYECQEQCAgEDQEJAQ0BBgQGCAQHAQwFAQYKDgUBCggFBA4EBg4aBhAQCgkCEQEICAcBBwIPAhILAgsGFgYKCBIEBgQEFQINAgwEBA8DDAgFAQYNAgkEDgkFDwMKCAoEBwIJAQYQDgYKCwEGBgQOBgYEBQIYBAQGDAUHFAYNAhYSBAYIBAoEBAQHAQgEBAYIFAcDFQEIDQELAQoKBAQGCQIIBwEKBAQMBAkBBwMKDAQOBwEHAQYKBAQIBgQQBAYEDQINAQ4fAQgHBA0DCwIYDgoEBwEHAQYICg4IBAUBCwMSCQIXAgsBBggRAQkDCgQKEggHAQgEBwEGDggGCBIJAgwUBgYECAcBFgUBDQILAhUBCQESCAUBChAEBAUBFg0BBgYKBwEIBQEKBgYGBAoLAggHAQkDDQEGBAYSBQIJAQYFAhEBDAcBCAQGBgYEBAUCCQMKBgcCCQUTAhcBBwIKDQEOBQIIDwEGCgsCCAcBCgQMBwIQEAQYBAQICggFAggECQEJAgkBCQMLAggMBwEMBQILAQYHAQYHAgsBCAYGBQEKBQIZAxIKDAUCDBAFAQgHAQYECQEIBAcBGAUCCwEKBggEBQQOBgwHAwwLAQsBBgkBBgwGrgIEBAYHAQkBCAgJAQcCFAUCCA0BCgUCCgQEGQEGBQIJAQwMCAYHAQcCEQEGCAUBCgQEBAQKBAQIBQESBQIPAQYECwEGDAUBCwEHAwoHAgoEBgUCDAYLAQYNAQYEBwENAQYOCBAIBAUBCAkBCBMBBwEHAhEDDwMKBQEICAYEBQEGCQEICQELAQcBBgYGEwETAhUBCQQOBwEKCAUCCQEKBAUBDQEHAQYEBAQMBAQGDwEPAgwUCggICQQNAQcCDBkCCAUBBgUBBwELAgoFAQoIBAoIBAYFAwwGBAcCFg8BBwYSBQIKBBIECwEJAgkBBgUBDwEGCQIIBAQGBQMLAQgEBAQJAgkBCAgEBQMXAgkBHAQEEgkBFAcBEwEHAQ0BCAYKCAcBBwEKDQEKCAgHAQcEDAUBCQIIBQIaDwQNAgkBBwEHAgkCDAcBBgUBCwILAQkFEAgUCQEaBwIIBQEHAgkBCQEIBggFAQ0BBgQEGAgaCQEJAhYHAQoHAgoEBgYEBAsBBwImBQIMBQMLAQYOBAkBBwIUBAQFAwoICggFAggHBBQEGgwGCggGCQEUBQIVAQYFAQcBDgUBBgYFAggHAQcCCgsBBgwQBAQEBgYFAQYECgoKBAkEDwIKBAcCEAQGCAgGBwEQBQEMCAQFAQYJAhsBBwEJAQYIBgQFAQ0CEBAECAQLAggECgwMCgkCCgYGCA4NBAwEBgQFAQwFARYFAg8BFQEKFggFAQ0BDwERAgsBChIFAwwLAw0BBgQEBQEOEAwKBBIIBgwSBAkBDwEHAQgKCAgFARAEHwIRARUBCAcBCAUBCAQFAQkBCgwIBQEGBBIKBAcBDBIXAwwEBQEJBA4LAQwEBAsBCBgGBggIGgQKBAQEDQEIBgQECAYGBAQVAggECQElAQgGCAQEBAQEDwEGBwEIBAQHAQ0BCggMGA0BBwEIBAYOCgYEBAcBCAYIBQIYCAkBCAQKBAQMBQEGCAUCCQIIBwMRAxAECgQJAgkBDQEIBAQHAQgPAQYEBA0BDggUBQESCgsBCQEJAQYECgQICgUBCwELAgoKCAoFAg8BEAcBDQEQCAQGDAYQEAQTAQsCDAQGBgoQBAQGBQEGCAgHASAIBAwKBgUBCCQiBQEeCBAFAQwEBAQEBgUDDQIIBwEGCQEICAYECQIOCgYKBAQFAQ4GBQMMBgUDCwMSBgQPAg8BBgUCCAYEBAQFAQcDCwIPAQYECgYFAQgEBgQEBAQGCQEJAg0CCAUBCgUBCAQHBAwEBQIJAQwIBAgFAQcCCAUBBggEBwIQDAsBBgQMCwEVAggGBggGBQIJAQoGDAcBFAkBCQEICQEIBK4CEAQLBhAECQEMDwETAh0CFAYIBwEPAQoGBQUVBRAHAgkCCwIJBhEBBgYJAgoIBAQFBAwHAQcBDAQHAQYFAQ8CCQEGBQEGBAQHAgqSAQUBCgQGBwEHAQgPAQcBDBYIDAgGBQEXAQ4IBAwLAQcBBgYFAQkBBgQEBQELAg4IDg4RAQ0BHQIKDgQGBQEJAQsBBgwEBQYSCAwNAQkBBgUBCQELAQcDDAQEBQIOBQIICCAIBAcCEAgIDAYPBBAEDggKCAYEFgcBBgoNAhMDEwIIDQEJAQwSBwEHAQgFAgsBCQEeBgR1AQkBCAUBBgsFFQEWBQEMCQEGBQEOEAUCCAUBBgYIBwEGBgcGFgQFAgsBBgUCCQMLARgHAgkDDgQHAQsBCQweBQEGBAUCDQEJAgwFBAwFAQcFEQEHAQsCDAwPAQgICwIIBAYSBAQKCB0BCwEGCAYEDwESCg4SBAoKCAoMBwIIDBgFBhECDgYEDQEGBAUBBgUBDgUBCg0BCgQEBAYEEQIICg0DCwEGBgQJAQ0BCAUBBgUGEgUCDQEGCQQMGAQECgQKCQEIBwEHAgoIBAoGBAYGDAcDCgUCDwEHAQYMCAUBBwEJAQgEBA0CFwEICwEHAgwMBAQGBAQECQEGBQMOCwIMBQMLAQYEBQIOBwEGBQEOEQEPAgkCDAgJAQ8BCBEBBgYHAgwFAggEBQEGBwIKBQEGFQIKBwEGDggFAQwEBgYHAQoJAggEBQILAQYECAQHAQoFAggECAQKBAYEBAYEFAgHAg4IBAcCCwEHAQcBBhoFAgwICAYIEBEBBgQSCgUCCwEGBgQJAQkCEAUBCwEOEAYEBAkCCgQJAQsEFOQDEgUBBwEIBAcBBwMLAhUBBwILAQkBCQESBAYRAgkDDAkCDAQEBwF2ChIIBwEOBgkBBgQPAgoIBAsEDQMSDAUBBwMMBAgHAggFAQcBDwIJAQcBFAUBBg4GCQEHAQsBCQMKBQMOBwEIBQEGCQENAg8BBgkBBgQKBwEHAw8CCAQGBgUBBgYMEwIIBAUBCwEHAggIBBAHAgsCCQQQBQEXAQYMEQEGBAQEBBIGCQEIBg4JAQYIBAcBBwMMBAcBDwEUBAUBGgsBCAoIBQIJAQYEBAQFAwoFAQoGBAYECgUBBgYJAggXAQsEEAkBCAYPAw0BCQIJAWoOBAUBBgcBBg8BBioIBgkBBwEIBAYFARECDgQJAQYEBQMRAwwGDggEDgQEBAUCCwEGBwEHAQ0BCAQLAg5nAQYEEwEIBAUCCgUBCggKHwIKCQIIBQEGCA4ICBQEGwEQBgwECgoFAxQJAQYFAQcCDgYKBgUBBwIKBgUBDQF8DwEGCwILAQkCHgUFDhAECA8CGAQIBwEIBQEKBAoIBAoHAQYFAg4HAQYKBQELAgkBEwQOCAQLASAKBhAgBBgWBQEHASgMBQEMCAYKDAYHAxIIBgwWCQEOEAoLAQgIBAUBEAQGFQEOBwILARAQIQEG1gEEBBUBBhgJAQYGDAcBDAUCCAQGBA4UBAgKCgoGFwEHAhYFBAwUDggEHgQeDAYEDQMKBiMBCB0BGgQJAgggBA4LBLYBCAUCCAYFAQgGDwEGBQENAgoGBwEICgcBDwEGBgQHAQ8EDggHAwoKBg4EBggNAQgYBAYIEg0BDAYKDgYGBwENAREBDwEGBgQEBwEHAQYMCQEuBgkBBwEKDAcORQQS7uQCvPwPLApwOCROjgM8FDA=",
  "chinese-simplified": "GiaAAsG9AQMLFjEBSVWxAWbZASq3BASGAvMDAQq/aQEGBAUEDQEHAQcDCwcTAQcEDQEGBgQEBQkZAw0BBwUPAgkDDQUUBg8BBhYIBwEHAQcEDQQOBQIJAQcBBwUPAw8BBgsBCQMLBA8BBwEIBQYVAggFAgoEBAQEBAcCDAQEBAgJAQkEFQMNAwoEBQEJAQYFAgoEBAQFAQ4GBAsEDQIJCRcDDgYHAQgFCBUBCQEGBAYEBAQMCAQHAQYFBQ4FAQ8BFAcDEAkDEwEGBwQMBgUCCQMKBAYEBAgQBgUCCAUBBgQFAggGBAYEBQYcCAQECgkCCgUBDgoEEhoFBA4EBQEMBgoIDwUVAQYHAQgNAQYECAYOEAQNAQoaDQEMBAgEBgQIBAoIBgwOBBIQBBcCCQYRAwsCCAQEBAQMBgUCCQMLCRcCCgsFDwEMBgQEBQEKBAUBBwURAQcFEwIKCAUBBgUCCAQVAgsBCAQJAQYFAggGBQUPBA8CCAcBCQENBAwGCQEJAwwEDQUOCQIMBgUCCQEIBAsBEAQEBQEMBgYQBAgJAgwIFAUEDAsDCgkCCAgGBQEGBAgEBAoEBwEHAQsCCgQPBRAECgkCDwEGCgUBDQIICAcBBg4JARcCCwMKBAUDDQsaBAUEDAUBBgQJAgkCCQEICAYFAgoFAhQGBAYEBgcBBwELAQoICggFAgoFBxMBBwUOCRQtBA0CDAUBBgUPJgUEEQQNBA0FDwEHAwoFAQgEBQEIBAYEBQEJAQ4EBAQLBhAFAQkCCwIIBAsBBwIIBQcfAQcHEgUCDgYEBQMKBQMLBxIGBgcCCAkFEQEKEAUBCgYFAQYNAgoOCgQEBgoFAwsCCQEOBgUBBgcBDAgFAQ4GBAcDDQQNAgsDDQEGBAUCCQEHAgwEBgkCCQEGEAcCCAUDCwIJAggQEgcMHAQFAQYEBAcDCwEKDAYLAQcBCAQTAQcBCQEJAgoLAQsBBgQGBAgEFgUBDAcDCgwECQQSBgQFAQcBGA8CChgIFwEMBgobAQgOBgcBBwcVAggEBQYVAQkCDQEGBAYECwEIBAgGCAkDDAYGDwEIBAQKBQEJBBQHAQcEDgQFAwoECAgIDwMSBgkBEQELBA4GBAUBEBsBCgkBBg0BBgUBDQEcEAUDCggFAQcCGAgQBAQGDA0BCQEMIAUBCgYHAQYIFgUBFBIKBAkBEwEJAQYGBQIQBQEMJggEBg4EBBIMDwEHAgkBCAcBCA4GBQcXAgsBBgcBBgYEBQIJAgkBBgcDDggEBwIIBwEGBwQMDAQGBAYHAQ0BBwMOCwIJAggGCwEJAQYJAQ0CCwMNAQkBDwIKEAcCDwQPAQYFAw8JLAQIBAUGEgoECgcBCQEIBAgRAQYEDAkDDAcBDgoKEAkBCBMEDgomEQEIKQEMBAcBCQEQBgwEBAgOBAYGDioIBhYIDg8EDgQEBhEBIwEHChgHAggHAw8BBgQGBAYHAQYEBQIJAQgIBAUPJwIIBAcDCwELAgoFAxAIBQIXAggHBQ8BBgQGBQEHBA0BBwEGBQUPBA0DCgUBBg4GCgYEBgkKGQIJCRoSBQEJARAGBBAHCCAJAQgFBRcBEAUCDAQJARAEBgYIDg4QBwIIBAYFAQ4KBAsBCQEQBgYFAQoYBAkBDhIUBwIIBBAGHAYGChwFBA4cPAYGEBAhAQkBCQQMBwEHAwwIBQIJAgkBBggHAQsCCAUDFwIMBQMMBwINAQwFARARARsCFA8CCAUHFwEHAQgLAgkEDQEHBxUBCgQRBBIGDwMWBggLAQcBEBIHAQgLBRIFAQoEBAQFAQgJAQYHAggIBAQIBAUBBgQEBAwIBAkBBgUCDAkBBwMLAQcBCQEGCAQFAQkCCQIJBRMDCgUCCgQGDwILAQwEBAQIDQMTAQcFDwQNAQkBCAYHAQ4IDAUFDwIVAQgFAgoFAgsBCwMKCgwNAQgFAgoKBAYEBggTAw0FDwEIBQEGBQMKCwELAQcBEAQICwEIBgUCCQEGBQEGBAQHARUCCwEOCAYEBAcDDwMLBhEBBgcBEA8BCwIQCwELAQkBCAcEKhIHAQYGCAYIDQELAQ4ECwISCBIGBQEIGgQJAgoMCBAICAUDEwEqGAcDFQESBAUGEwEGBQYSBggEBQIJAgkCCgcDEwIJAw0EDgYQBwEHCBQGBgYFAgwLARECCQMLAgsDCwEIBwEMCAgFAggGBQUPAwoFAgkGEgcBBwQPBQ8BCAsDCwENAg4GBAYJAQcEDQIKBQEKBg8BCAQGBwEIBQUUDgUBBwINAQ0BBwINAQkBDAUBCwIKBwMOBAYLAwoFAwoEBAUCCwEGBBAEBggFAQYICQENAQYNAQkBDgQEBAYHAgoQBQEJAQYMBAYMBgUBEQIMBwEIBgUCCBAECAwSBB8CFQEGBBMCChINAQoFAwoFAwsBBwINAgoEBwEHAQoECAQIBAQEBAwQDAQEBCQMCQIPAhAIDgUBBgcBDgYIBgQEBQQMBQELAggMCAQFAQcBFQEMBAUBBgUBBggEBQEIBAcBBgQFAgkBEAQHAQYFAggNAQcBEQEUBAcEDwMKBAcCCQIMBAkBBwEGBQELAgwIBQEMBQEMBQILAhAEBwIQBQEIBwUQCQEMBAUBDQIMBQEICAQEBAcBCgkBDQEOCwELAQgGBgYKBBYFAQgaBwIJAQwGBggFAg0BCQQOCwEGBAYJAQYIBAQNAQYFAwoEBwEMBgYFAQgFAQgFAwoGDAUDDgcCCgUEDAQKBQEGBQEIBAQKBgQEBgUCDQEGBAcBBgUCCAcCHAwLBRIEBAUCCAYIBgcCCQEQBwINAQcCCQEHAQYEBwEQBwENAwwVAgsCCQMLAQcBCAQFAQcDEgkDCwQjARIECQEUCAgMCgkCDgUCCAUBFgQECgQECgYGBAsBCBIEBQIJAQsBDAUBCAYGBQEKFBASBggKCQMKEBMBDgcBBgYGCgUBEAUCCwEMBAQFAgwNAQ8BGQEIBQEOBggMBA8EDQEQBggcCgwGBAQGEQEOBAsBDgQECwIOBAgHBhgGCBsBDgQUDBAGBAQIFAQIBhYOBQEICAoWcBIMCwEGHQMOFgwECBEBBgYIEhEGEQETAgsCCQEMBQEHAQcCEQIKBAQOJwEGBgQHAwwMBQILAwoEBAwUCBwlAgkBBwMKCAUDCxQvAQcCDQEHAQ4KBAcHFAkCEAQEBAcBCQEJBQ8BCAcBBwEIBgQIBQYRAgkBCAQLAQcEDAcBCwEGDwIICAYFAwoGBQEJAwoEBQEHBA4GDwEOCgQEBg4EBQEKBwEIBwcSBQgXBhMDCggGBgcBCwEMBwEKDAYHAQgECwILAQYFBA0BBwQRAQgGBggHAQsDDwEMCgUCCwEIBgQFAQcBBgYEBAUFHAcGEQEIBgcBBgcBBwIMBwEGBgQEBQISBQINAQkBCAoEBggEDAcBCQEMFQIKBQEIDQEODQEGBgYEBwEKBAYECAQJBxYMBQILAwsCCQEHAgkBGBUBBwEKBgwJAhoEDwIMBQIODQEKCQEIBAgGCAcBBwEIBAQPAQYICAQECAgICwEeCgYGBhIGBg8DDQEGBA0BCAwHAwwOBwEGGiIEEwEcCBIIJgYSDAoRAgkBDQEG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",
  "chinese-traditional": "GiaAAsG9AQMKBxMrAQjJAyr3cwEGCQQNAQcBCQIJAQ0BEAoEBgQNAQcBDwEGBgYFAgsBCAUBCQMaFBYICAQHAQYHBBAEBwEHAQcCCAcDEA4NAQcBBwEJAQYPBRMCDQIKEAQJAQoEBAQRAQkEEAcBCgobAQoEBAQFAQ4HAg8EDQIJCRcBDgYHAQgFAgsCCQELAQYEBgQEBAsCCgQjAQ8CFAcCEQEHBBUBBgcEHgUBBgUDCgQIBAwGBQIIBQEGBAUCCAYFAgoFBSgOCQIKBQEOCgQSGgUDEgYKEAgPAhUBFQENAQYECAYIBggMBAkBChYEDQEICAgECgQEBAUBBg4FAQgOBBIQCwEHAgsCCQYRAg4EBgYEDAYFAgkDDAkDDggOBQEIBAUBCAQSBAUBDAQIDQENARAEBAcCIwEJASEBBgYFAgoHAQYHAggIBwEMDA8BCQIMBA0CCQEOBAgFBRYECwIdAQsBCAYEDAQJAQkDDAgUCQEIBgcCCB4EBgQIBBIGBQIIBQIKBBgGBAYFAQkBDwEGCgUBDQIICAcBBg4KBBALAwoEBQMMCQMMBgQEBQEMEwIIBAUCCAgGBCgEBgQMEAoSEAsDCg4FAQoIBQUPCxoGBwEMBQEGBQomBQMTAwsDDAQFAQcBBwMKBQEIBAQIDBwEBAQTAggFAQkCCQMKBQELAQYEBAcBBgQZBxIEBAoGBQUOBQMRARAQBgkFEQEKEAUBCgYFAQYNAgomCwUOBAUBDgsBBggLAQ0BDgUBBgUDDhcCDQEGBAUCCgUCCwEGBgkCCQEGEQEHAggHAggMEwMQBAcDCggFAQYEBQEGBQEOBgkBDgYMBQEJAhAFAQsBCBAECwIIBAQFAQYIBQEQBgQKCQMSBAUBCQQOBAYEBQEQCgQPAgoECAYSBgwMBQEMCwEPAgoIBgYHAQcEDgYHAQwTAQwJAQkBCAQLAQgECAYICwELAQYGEAYEDgYHBCgGBAUCDggEBBcBEhAPAQwFARgOGwESBg0BEAcCCgYcBQMKCAQHAgkBKAgGDAsCCwEWFwIOBgcBBggIEgQICAgKBAYECQEUCggFARUBCAQKEAYGCQIYBAQGDQEIBAoFAQgVAQcBFA4ECwILAQYIBAYEBQIJAggNAQ4ECAcCDwMNAQcBBgwECgYHAQ0BBgUBCQELAxIGBAcBCQMPAQgFAgoNAQkBDwIKEAkBBgcEEAQFAQ4FAQYEBAQODAgEBAwGCgQKBwEJAQgECBoECAkBDAcBGAoICAkBCAYUBgoJAR4KBwIIEhcBEAcBCQEQBQEXAggOBAYGGAsBFgcBBwEYCAwGDAwEBAgPAQgEDQELAQcFDwMKBwIOBQELAQYEBgUBBgQEBAQFAgkBCAgEBQUXBBQEBAcDCwEOBgUDEAgFARkBBwEHBQ8BBgQLAQYEDgYHBA0CCAoIEAQMBAoNBQ8DDQIIBwYUCAYIBAUBEAYEECYJAQgaCgYFAgwECQEgCA4PAR4EBwEGCAQKBAgMDgYGBQEGBAoECgQWEhQHAggEEiAGBiYEBhoGBA4OIQEGBQEOFAoEBA8BCQEJAwwGBwMMDQILAQgMCgcCCAUBBhAMBAwHAg4GBwISEQEGEAUCEwERAggFAQcDEgYGCg0CCgQIDQEKBA8FFAcBBgkEFwEGCAYFAQcBFA4HAQgKBQEGCAUBCgcDCwEICA8BBggICAQKFAQEBAQTAgwKBQEGBQQPAQYIBAYHAgwFBRMCDwIKBAUBEQIJAhIEBAgMBA8BBwMPAw4HAQgNAQ4IDAQFAR8BCAUCCgUCCwELAwoKDBkCCg4GBAYJARMDDQUPASALAQoHARAECAsBCAoTAQcCCAcCFQILAQ4IBgQEBwMOFQQMBwIQCgUBCwIQCwIKCAkBCBIGDwEMBwEJAxAEBgQKBwELAQgGBAYFAhIIEQEIBQEHAQ4UBwIJAQ4IEAgLBDAIBgQMCAcDCgQFAhMBBgUCCQILAQkCDAUBCAkBCgQFAggPBBUCCAUBCQMOBhAFAREEDAYHAQYFAgwLARECCQMmBwEMCAgHAQYGBAUDCwUPAgkGLQMKBQEICwMLAQ0CDgYKJAUBCgYPAQkBCgcBCAUFFCUCCAUCCQELAQkBBgYFAgsCCgcBBggFAQYJBAwFAwoEBCAHAQYFAQoFAQYICQENAQYNAQkBDgQGGg4FAQkBBwEMBAYEBAQGBQETAREBBwEGHQEGCAgFARIEDQEIBwUYBgUBEgUBBgcCDAkDDgUDCgUBEwEHAQcBBwEGBwEHAQoECAQMBAQEDAcDCgcBBwIIBAwSCgkBCQENAxECCg4FAQYHAQ4GCgQECQQRAQsBCAwMBQEHARcBCgoJAQoEBAUBCAQHAQYJAQkBEAQHAQsCCA0BBwERARgHAQcBCQMKBA8CDAQJAQcBBgUBCwISBwEMBQEMBAQHAgwPAhAGBgYQBwIKBAQEDQIMBQEICAwHAgoJAQ0CDgQGDAYGBgYJAQYSBQMgBgcBCAwGBggFAgsCCgUCCgsBBgQPAQYIBAQPAgkEDgcBDAYSBQENAwoGDAUCHgUEDAQKBQEGBgYEBAoFAQYEBgUBJwEJAQcCHAwLBRMCCQIMBggGBgQFAg4KKAcBFhEBHwEJAQkDCwEHAQgEBQEHAUYSBAkBFAkBCAwFAQcBCwEMBQIIBB4KBAQKBgUBBgsBCAkBDgcBCAkCGAwFAgowDAgKCAQGEBMBDQEJAQYFAQgEBgUCEAUCFggQDQINAhQFAgoFAQ0BCAgMBBEDCgYMFggKCwESBAQFARIOBAkCDwEGBAoaBwILAQ4HAQgbAQ4FARQqCAoKBAgGCg0BDAgGCAoGDwEiDwEJAQ4LARIKBQEUCwEMBggVAQYeDAQHARMBBgYEBBIECAUGEhALAggICQEGBwEaBAwMDgUCCgYEBgQHAQ0BDAQEBwIJAgohAQgcCgwPAgkBBgYECAkBBwIJAgkCCwEKDAUCDBAECgQEBQYbAg8BBgQECAcBCQQNAgoHAQcBCAYEIQMMBAsHEgcBCwEGDgQECAsDCgYGBwMKBBgGDgoECgQEBggGBQMOBwIJAQcGEjEBDgcDDQEGBQEMBwIQBgYFAgoECwIuCQEIBQEHAQoHAQYFAw8BCAUBCgUCDAYHAgkEDQEGBAUCCQMYKQIIBQIJAxMBBgYECAQEBAsBDgcBEgQGCBAIBwEKLA0BDg0BBgYHAgsBCgQGBAgECwEHAQYJAQYGBQIKKAYGBAcBDwEHAQoGDAkCDgwFAQYJAwwFAg4NAQYgBggGBwEIBAQPAxYEBAQEBAQFAg8BBggGEwEIBgYOBAwPAyoGBgkCCg8BBwMYCA8BCAQIBAgGBQEGBQIPAhQEGAoSCggGCwEGBwEMBAoMBAkBEwEKCAgFAgkBGAoFBBAJAQYcBAoGBAkCCBAWCgYECBkBBhYFAQYJAgwTAg4hAQYGBAgIBgYEDQUQBAgMCg4MCgYEBgQNARIICggICgYFAQsCDAQEBQELAQYHAQ0CDwIQCgUBBwEQDQEIFh4FAQgLAQcDCwETAgwMDQEGBAUDEAQMBgQKBAQHAQgSChIOCgoGHAYEBBQEBAoEDwESHQILAR0BGQEGBQIO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",
  "chorasmian": "GiaAAqG8CBs=",
  "coptic": "GiYZAh0BzAEukwkCCQEHARQkOD4GJwHdAQ3WZ4YJhgEGBQHoFekac/MBBrwEOQHjvwYC+RIb",
  "cuneiform": "GiaAAsH9CJkHgRBu4QEEIcMB",
  "cypriot": "GiaAAsGBCAIPLGEIkxsFEAUrWwEKBg==",
  "cypro-minoan": "GiaAAsGBCAGhugFi",
  "cyrillic-ext": "GiaAAoEPL2UdQX2dXwroENk0H8HhA1/d3wIB",
  "cyrillic": "GiaAAsIJ/wNfoQIBQQHMcQ==",
  "deseret": "GiaAAsGNCE8=",
  "devanagari": "GiaAArgIiRl/oU8p9wwCcsgBIm64E8mJBAnhAh/ByAMJ",
  "dives-akuru": "GiaAAsHhCAYSBwcTAQcdPwEJCysJ",
  "dogra": "GiaAAroiTwvPWgKCF8mJBAmhvwM7",
  "duployan": "GiaAAi6hCQEGMwHRcwKCF+AhibcMauEBDCEIIQkZBw==",
  "egyptian-hieroglyphs": "GiaAAsG9CdUIwRGaHw==",
  "elbasan": "GiaAAi6cCZkCECUGbgQE3IcB6fwGJw==",
  "elymaic": "GiaAAoG9CBY=",
  "ethiopic": "GiaAAtwJ5TtIlQEDDQYQBQMNKFUDDSBFAw0GEAUDDQ4hOHUDDUKLAR9HGYFoFkEGEQYRBhEGEQYRBhEGEQbT9AMFEQURBR8GEQbx8gkGEQMLAQcO",
  "garay": "GiaAAtgVHgjDnAglUxxLAQ==",
  "georgian": "GiaAAi6kE68sJU4MBy+BLypbAroOzTIlTgyIBA==",
  "glagolitic": "GiaAAi6YCQT+BQaEBOQtvj3NLl+GCdjgA6PmCQYRECcGEQEHBA==",
  "gothic": "GiaAAi6bCQEIUv//Bxo=",
  "grantha": "GiaAAuMiAScBjAkWYw3UQwUBQQINAacMAsoDuBPptAcDCwcVAQkVLwYRAQcEDQkZAQkCCg4NBhMGFQTBMQEG",
  "greek-ext": "GiaAAsF5FTEFESVRBREHEgQEBR5DNG0OIQ0hBQ8SKwIJCA==",
  "greek": "GiaAAqELBxUFFQYQBRMrXA==",
  "gujarati": "GiaAAuMiAScBuwQCCQgVAgkVLwYRAQcEDwkXAgkCCiEDDQsnBqVUAtwCphTJiQQJ",
  "gunjala-gondi": "GicBCgUIJgUDyAEuQEDbIQHPWgIbAQkBFNgH9A6p3gcFDwEHJE0BBwUbCQ==",
  "gurmukhi": "GiaAAuMiAScBuwICCQUVAQkVLwYRAQcBBwEIBQQTAQkCDBEDChEQy1YC3AKmFMABiYgECQ==",
  "gurung-khema": "GiaAAoojt94KOQ==",
  "hanifi-rohingya": "GiaAAhYgohUeCEJA6AHvZAKCF+mcBydhCQ==",
  "hanunoo": "GiaAAoFaFtcjAoIX",
  "hatran": "GiaAAth9qaMHEikBDwQ=",
  "hebrew": "GiYa5gHPCQGVCjZ/Gj8FuWgFvgLEFKPVBhk3BAwFAQcBBwk=",
  "imperial-aramaic": "GiaAAsGeCBUvCA==",
  "indic-siyaq-numbers": "GiaAAo4WcwmhAgmDlg9D",
  "inscriptional-pahlavi": "GiaAAoGrCBIxBw==",
  "inscriptional-parthian": "GiaAAsGqCBUxBw==",
  "japanese": "GiaAAsG9AQMLF3lVsQFmz3UBBgkEDQEHAQkFFAYKCAYJAQoFAQcBCAcBBgwFAhEEEQIKHgQWBAQHAQcEDAcBBwEJAQcBBwQNAggHAwoGBggNAggFAQkBBwIPBRMCDQIVAQYECQEKDBEBCQQaBQEnAQoEBAQFAQ4HAQ8EDAQEBQUgDQEIBQENAQgIBgQGBAQECgQGBAcBFgUCEQEUBwIQCAUBCAcBBwEGBAQFAhcBCgUBBgQIDwEIBAQEBQEGBAcBDAQFAwsFHAYUCQIRAQ0BCgQSDgwFAggKBgoQCA8CKQENAwoOCAYJAQgEBAkBCggKBAQNARAIBAsCCAoSBQIIBAoEEhAKBwILAgkGEQMKBAQMBAwGBwYSCQMOCAQHAQkBBwEHBA0CCA4EBQIJBBEHGg8CCgUCFgsCCwENAQcBCAcBCwEHAgsBBgcBBwIJAQgGBgYMDwEGBQEKBAYHBRsBCAcDCgoECgYLAg0BDQYcBAgJAgwJAQYOCQEIDQQQBwEKBgQGBAQEBAgKBgUCDQMLAgkBGQEGBwINAQcBCQEGCgUBDQIJAQgHAQYOCgQECwMPAggFBRAJAw0BBgQEBAwGCwMLAgkBCAgGBCQEBAsBDQEHAQsBBgYGCg8BDQYYBQEGBAgFBA8LHQIIDgUBCwkmBAUBDgYFAxYFAQcDCgQIBQIMBhwSBA0BBgUCDQIKCAQLAQcCCCAFAQgHAQgHAQwJAgkCCAcCIhMBCQEHAQsBChAGDgUBEwEKBDEBBgQLAQwECQIQBggHAQ0BDjEBBgQHAQgFAh8CCQMXBQ4EDB0BBhoMBAYJASgECQESBhYFAgocDAUBBgQEFBQEBBYSCAUCFAgEDA0BCAoKGAQGEgwEDAkDEAwGBAkBBwEIBAYWBAUBDwEIBQEJAQsBBgQEBwEIBAgGDwIOBg8BCAoECgYJAyYGBAcBLAYNAQYQGgUCEAwGGgYGCgYJAggMBwEIIgYFAQYIBAcBCwEWCAgIBgwLAgsBDAYHARUBDwEGBwMOCA4ECgQGCAoKBBwICgYSBgYKCwMMBggEBgQKBAQFAgoFAQ0BDwEHBBIFBBIPAQ0BDQEHBBQGBAUFEQENAQ4MBwIPAw0BBwEGDAQGBQMKBAsBCgoJAxIGDAYGBAQMBAYIDA4EBhAGBAsBBwENAQYTAQYFARgKCAQEDBAOBAQHAQwIDA0BDgkBDAYiEAgIBCYmEQFFAgsBEAUBCg0BFgQGBiMBHgUBFhgQBAgECBAEBgQXAQkBBwEHAwoJAwwECwEGBAYEDAYEBQIJAggMBQYQBwQYBAcDCwEOBwUOBggFAhIFAgkBBwUOBgQGBQEGBAkBBwEHBxMCCAQGCAwEBAgKCA8JGwEGBQEHBAwEEgUBCQEQBQEGCgYmCQEIGg8BBwEMBAcCCwEGDgQkDwERAgoFAQ4JAQYUCAYGBwcWBg5FAQYEBBQaBgYIBhgEBgkBChoKFAQSBgUBGgcBDQEICgUBCAQFAwwGBwQMCAUBCwEICwEMCgcCCBAMBAUBCAcCDgYHAggKBA0BBhAFAyMEDQcSBQEIBgoNAgoECA0BCgQRAxkCDwIPAQgGCQEGBQQTAQgJAQcBBwIJAgkBBgUBDQQNAgkFEAgNAggIBAQIBQEKBAYOBAQEBgQHAQYHAQsBCgcEDwEGCAQGBwYRAQcCDQMPAg4FARECCwENAQwHAQ4EDwEVAw0BCAgOCwEKBgYEBB8CCAcBCAUCCwELBhQEEg8CCgkBBgYEBgkBDQEHAw0FDwEMBBQFAQwFAg4EBQEJAQsBCAcBBwETBAwJARMCGAQKBAQHAggJARMBBwEHAQcCDwEGBgUBCwIQCwEKBA0BChARAwwEBwEHBBIEBwIKBAcBBgUBCAcDCwQWCAoGCAUBCAQHARYGBAUBBggICAgKBwcUJgYYBAUCCAUEGQIJAgkCCAQJAQcCCAoICQIJAgwGCQIRAggFAQwEBgYGBAYKDAYKBgYFAgkCDwERBxUBBhsBDAgIBQIOBwUPAQcFEQIJAgsBGQMKBAUCEwEHAQ0CCgoQDBEBCAgWBwIYBwEHAQwEChcCCAYICQEJAQwGCwEIBQEICAQGCQQMBQUWBQEOBgQHAQYGDQEGCAkBDgQMCgwECBgOBAgHAQwUBAkBEAQICAgYFB4EDA4EBBIKFQEGCggNAQoEBQEGBA4FAQ0BCAQMCgQIBA0DDQEMBgUBBgQIBwEGCiYJAQ8BDwIKCwUOBwEOBgoEBAkEEQELAQgMCAQFAQcBFwELAgoEBQEOBAUBCAQHAQYJAgkBEAQHAQoFAxEBCAYKBAQLAgsEDwEKEwERAQkBCAQFAQsBEgcBDAUBDAQLAhAGBQMQBAgGFwIKBAUDEQIMBAgOBQEJAg4GCwIOCggKBgwJAQgEBgYGBBoHAQcBCAwGDgUDCwILBA4LAQYEBAsDDgUCEwIJBA4GBQIIBgQECgYLAwoGBgYFBxgGBQQMBAoFAQ4EBAUBCgoEBgUBCQIMBgwJAQcDFgYECAkDCwEKBAcBCgQGBAYFAQYFAhAHAQkCIgcBEAcBEQISBAkBCQEJAwwECwEHAQcBDAcBBggIGgUBEQEGBAQQBAkBCAgEBQEGCQIOBQIIBQEJAQYQBAcCCAoFAQcBBgsCCAgPAQgPAQ8BCQEIBwQODwMRAgkBBgQMCAQGCAQWEwINAQcCCQIVAQcCDQIJAgsCCwESCAYHAQ8BCg4OBwEGDgcBBgQIBwQMBgsBCwEVAQgECg4EBAQGBgsCEQIKBAQHAQcCEQIKDwEHAgoOBwEIGwEOBQEKGAwPAQoTAQYOCggFARAEBAoKBg0CIAQPAQkBFAQhARUBDBAIDgUCCAgWCwMNAQwIBAYEBAcBDAQIBQMKBwEMCQELAQYJAQkBBgcCCBEBBgwMDQEKBQQMBwILAQ0BDAUBCwIMBggZAQgIKg4EBQEICBEBIgcBDgUCHAQKBAYHAwoMBAwFARAHAQkCDgkBCAUBCAcCEQEUBgYECwcSBwELAQYOBAQEBAQJAggGBAsCCDEBDgoEBAcBDgkCEwEHAQYGBQEIBwErAQYPAQYHAQYEDAcCHAYIBAoECAUBKAYGBggICwINAQ0BCAcBDAYGBAQFAggGBAQEBQIYBQQYBAkCCAUCCQMMBQQaBAgKDgcBEgQGCBAIBwEICBECCBQHAQ4ECQEGBgYKCgYJAQgGCgUBCgUBDAUCFQEeBgYEBwEPAQcBCgYMBAUCGgUBEwENAQ4NAQYIHggHAQgKBA8DDggEBAkCCAQQBgwUBQEODgQMDwMMHQEIBgkCCg8BBwEGBAYICAYQBAgECAYFAQcCEwEMCAQYHAoOFhAJARIJARsBCggOJwMOCwIgBggUCAQkEAgYFgsBBgoKIAwaBgQPAQgSBQMKBgQeDggECgsBCgwSCAoQCgoLAQwEBAUBBhEBDQIPAhIIBQEIDg4GFhoEBQEIBAcBCwYZAgsBDg0BBgQEBQEMBBIECgkBBwIOFggUBAoKBgYIBhMCCBAEBAoEBAsCEgcBFwILARwZAQsCCAwJAgsBDAUBEQENARUBEhgKBAwEBgYFARQGBAQWJhMBEgoEDAQHASIECgoHAQgODAoFAQgyBhsEEAoEKAkDCwILAQ0BDQEIBhAKECYIChIaGgoKEAgFAQkBBgoFAg0CGwITAgoEBAYEBAUBCgUBBgcBCwMPAQcCFAQHBAwEBgsEDgQFAwsCCAYHAQcCEgYJAQcCCwEGBgwGDAQMDQIIBwEJAg0BBgQGBgoFAQkBBgYJAQ4OBQIQBAUBBhAEBCUDCgYSCA4OCQIMDAgECAsBDQMKCAQIBAUEDAcBBwIKBgQGBgcBKgQIBwMQBwEIBAQGCgkBCwEHAQYFAggGCAgECAYGBgYHAgkBIAcCDQIKHQEGBAgOJwEOBAUBBgYcCwEaBgYaBAoPAQgGBgYFAggQDBQHAhEBBgQECQIMEgwUDAUBGAsCGgQMCgwwHQEIBgQQCgsBDQIKBAQEBhIIBQEMDAoEBAYJAQsBDQEIDBsBCgYKEggMDgcBEBoJAiAEBAUBDwISBgUCCgcDCgYGChQGCwILAQwHAiATAQgIBAYNAQkEGAQNAQgGDgQFAQcBBgYIFgoQBgUBDgcDCgcBHgcBDAkFDwEIBgkDFBUCEAQKCAQHAQgEBAUBChUBBwMUFQELAhAICgkCCQEHAQYEBwEGCQEHAQcEDQEKBgUBDgUCDgYEBAQFAQoEDwEGBgQLAQYIDgUBCBkBBwEHAgkDCgQOEAQKBAUBCQEMGQEKBAQGBQEHAwsBBgQSBggGCBEBCAUBBgUBCBwGCQIKCAwHARQODAkDDBAEBAgHARsBDQMMEwEHAQoEBA8BCwEQDgQSBwIQBAQGBAYFAQgIBQEHAQcBCAUBCQIQCQEGBAYKCAgIBAgFAggKEAYEBAQFAQgEBAUCDQEGBgkBBwUTAhcBBwIJAQYJAQwHBBMBBwIQCgYHAgoEDAcCCQEICBgMCA0DDAcBEwcTAQgFAQcCFAcBCgUBCAYEBQIJAQgJAQgGBgQODAcBCwISEgcBBwIKCgYHAQgEBQIJAQgEBgkBBg8CCwEJARMBBwEIBhIFAggHAQ0BCAUCCQIICwG2AgQEFg8CCQEJAQgPAREEDgQEBgUCFwEHAwoEBAwMBwENAQsBDQEICAUBCggJAQoEDAUBGQEMBgQKBgwFAQsBBwMRAQoEBgUCCgoOFgYKBAQOCBAIBAQJAQcBDg8BBwIJAQYJAg8DCgUBEAYEBQEGCQEICQEHAQYFAQYMEwEGDAQQBwIJAQgHARYEBggJAQwHBSsBEgwMBAQMChAKBgUBBwIYDQEMBgUBCAkCDwEHAQwECggECgUBCAcBCwEQBgQGBAcDCggFAQoIBAsCDwEIBAUBBgYNAQ8CCAcBCAUDCwIIBAkCCwEHARcDCgoFBBYOIwIKBAYEBAQFAQkBBwELAhAaBAoOCAQNAQ0CCAQECwEGBBAZAwwEBQEHAQYEBQIMDAUBDQITBA4KEQIMDgoGCAUBBwIJARAKCQENAQYMNgQECQEUBAUBCgoGCAkCCAwFAQ4IEAgICgQECgYECAcBFAQJAwoGCAQNAQgJAxAaBA8BBgoIBgkBFAYKEggNAgoGBQQMCAQFARIEDgoICgYGBBgKDQEHAQgEBgQHAggHAQwHASYEDBAHAQ4WBQIJAQYKBAoNARIQBwEGCwMMDgUBBhILAgoUDgQIBwEGDQEIBgQFARIEBQQNARcBEBAIBQEMDwERAQsBHAUCCggJAQkBEgcBCBAWBQEgHQEGCQEMBAUBEggMEAQfAhIEHQENAg0BDhwFAQYEBQEOCgQHAQwKBwMZAQYGBAUBCAUCCgkBDgQEEggWBggIFAUBBgoEBAQNAQgGBAQIDAQEDgYWJAYSCAgPAQYGCAUBCgoEHB4GCQEGBAYOEQIICQEZAgwUCgYECgQEBA0BDQEKBAQFAQkCDgYKBAYEDQIJAQ4GBAoJAQYKCAQOBgUBCQEGEAUEHAsBCQEJAQYEDhUCDQEJAgwEBgYECAUBFwEQCwEYBAYMBQETARQRAgwECAYEBgQGDwEGBAcCCQEKCAcCCA4LAQcBBgYHARAGBQEmEAUBDgcBHAgQBQEMBAQEBAYHAgoEBAgECgYIBQEGCQIOCgQRAgkBDgYEBQEIBgUDCwMYDAUBBgQHAQoEBAYECAUBBwMKCQEIBA4GBgYEBgkCCAYICQIIBQIIBQEKBQEIBAkBBggFAggGCgQECAUBBwIIBwEMBAcBEAwKBhAGBQEQBAUCCg4LAQkDCgYMBgYOBAQEBQEIBwG8AgYKBAoEBAQEBAoKDwETAh0CCAwGCQEHAhAICwEHAg8JFwIJAgsCCQURAQYHAQgEDwIIBAUCCAgGGwMVAQcBBwEGBQEJAQacAQUBCgQHAQcBCBQICh4UChYOCAgTAQgOCQEGBAQECgUBCggEDgYTAg8BHQIaDAkBHAQHAwoICggNAQkBHgQEDAoHAQYHAQYIBQEMEBMCCwIeDwEGBQMQEggHARIaBwMQBAkBBg0DDgUCCA4HAQwICwEGBwEIBQIKBwIWCgYFA3UBBwEKCQENBRQHAgoGBQEUBgYMEAcBCQIIBQEKBwMMBwEGBQEMBQQNBA0BCQYUDgcBCQEHAQgEBwEIBAUCCQkXAQgEBQEGBAcBCwIKBwMKBQEHBRAFAQwEJAYEBAoECAYSEggaDQEGCAoQBAwKIA4oBgQvBRIEBAQVAQYJAQYNAQYFARYKBAQEBgQKCgwEDQEKCwEIBA0BDQMLBhYEBwIIBAQHAR8BDgYdAQgHARQWBhAGEAsBCQEGCg4HAQgIBAQWGgQGBBgEBQEGBQImFAQsBiQLAQgLAQwEBBQTARMCEAUBCAQHAQcBCAYLARQOBA4ECwEKGAQODgQcEAUBCBoLAggSFAoRAQ0CDggHAQg2CBIHAQsCEhQVAQYEDgYbAhMBCAQEEAwKBAsDCuwDEgUBCgUCDAQFAQYFARAFAwsBDAoOBQEGCggGBQERAggICwEIbgoOBAkBCBIJAQYEDwIJARkEDwQQBAgFAQcDCgYRAQYFAQcCDwEHAgkBCgYJAQYNAggFAwsBCwEJAwoFAwwJAQgFAQ8BDAUBDAQJAQYECggFAggHAggEBgYGBAwGBgwEDQELAQoEBAUBFAgGBgQFAggEBQEGBAgGCwEGCgcCDgQFARIICAYGBAYEDQEgBgQGEBIjAQsBBwEMCAUCCQEGCAcEEQEGDgYRARAHAQkCFgsEEwEIBgYSCAkCCQFqBAoEChsBBisBCAYOBAUCCgQRAg4ECQEGCAUCDAsBBwEICAgEHwEKBggFAQsCCgR/Ax4GCQIPARIKBwIIEQIKBgYEBAYXAQkBDgYIBAgTAQkBDh4GCg4OBAUBBhAQBAcBCgYFAQsCfgoGEAgICBYEBQEKDQEJAQgJAQcCCAYGCBYkBAoHAQYFAw8BBwEVAQ0EGQIIBggEKgoeFgcCCwETARIFAQcBDgoODAcBDAUBBgQKDQMOEQIKHgQFAgkBCAUDEgwHARMDCg8CChECGAoGDA4eBNoBBAQFAQoHAQYaBwMQCAYMCAgGBAUCIgcBBgYEBBEBEgcCCQEIEAYGEBoEDBYUCgQIBgQIBQEPAQYEEggMGg4EBg0CCjsBCK4BBwEKBAQOBwENAggEDAQNAQkBCBcEDQEMEQQMBAkBBwMKCgYOCgUBBgUCGQEOCgQXARgeBhkBCQEIBBcEDwEIBAwJAS4QDwEIw/0CXMQDBA==",
  "javanese": "GiaAAtd9AoIX6Y4ETZ8BCh8B",
  "kaithi": "GiYa5gGNIwnLWgIK+BbKIf/nAwmhoQNCmgE=",
  "kana-extended": "GiaAAvO/AQOv/QsDCwYRAQeiAg==",
  "kannada": "GiaAAuMiAScBuQwMHQIJFjEJFwQPCBUCCQMXAREBBwMNCRcCvj8FARAwBK8MAtwCphTJiQQF",
  "kawi": "GiaAAsH5CBAlKFkc",
  "kayah-li": "GiYa5gHXfQIK+BbpjAQv",
  "kharoshthi": "GiYa5gHXfQIK+BbpkAcDCwEPBxMCCRw/Ag8JIwg=",
  "khitan-small-script": "GiaAAoi9C7ls1QP+Bw==",
  "khmer": "Gic/gwEdfhYEHItbXcEBCSEJ4Qcf1xgCghc=",
  "khojki": "GiaAAo0pCctUAoIXyYkECaGnAxEnLg==",
  "khudawadi": "GiaAAokjAdFaAQ8B8hbJiQQJgaoDOoEBCQ==",
  "kirat-rai": "GiaAAsGyCzk=",
  "korean": "GiaAAqPCAV2fAxzBARvB5gOjVw==",
  "lao": "GiaAAsM3AQYFBA0XMgUWMwQMBQYRCRkD30QCghc=",
  "latin-ext": "GiaAAsEBMGUfReYC0QUJFwUPCR8kTQELATYMr2e/AYEEnwHlAw3cBIECCxsTzAGbLR+B6wOtAeECAQYFBzsN",
  "latin": "GidegQJfogJDAdMFARYoBEkBBwELATYMsnMOBBEBCwIJAgwIGQEPARbQAewB3gEE/gEG1PMG/AM=",
  "lepcha": "GiaAAsFtN3cOJQL9DgKCFw==",
  "limbu": "GiaAAokjAbk+HkELIQsgCQuPGwKCFw==",
  "linear-a": "GiaAAs+BCCzzE7YCgQUVQQc=",
  "linear-b": "GiaAAsH9BwsbGTcSKQEHDiMNYXqBAgIPLGEI",
  "lisu": "GiYa5gG4CCKGdfU/AY3TAy/A6wM=",
  "lycian": "GiaAAvR+zYgHHA==",
  "lydian": "GiaAAi70tQHf6wYZPg==",
  "mahajani": "GiaAAi7bIgvPWgKCF8mJBAnBpAMm",
  "makasar": "GiaAAoH5CBg=",
  "malayalam": "GiaAAs4JON0YAScBuQ4MHQIJMmkCCQUVDyUZ6D0wswwC3AKmFMmJBAI=",
  "mandaic": "GiaAAsAWgQgbPNteAoIX",
  "manichaean": "GiaAAsAWl2cCghfo4AaBMyZXCw==",
  "marchen": "GiaAAtiUAcnaBx9FFS8N",
  "masaram-gondi": "GicCCgUIJwXMAW5A2yEBz1oCGwEJARTYB/QO6dwHBhEBByteBQEHCCMJ",
  "math": "GidegAIOCgpMQJcIAQYFARIEBgoZAQwHAQcBDAQYDokBECUGHRhACQE3AQkBxXABOQYUCAYIEg4QIwEJGjkMgQEMIgkKNxIpAQcKGSzbAR5BNYMBAQeLAqkEAxASBwU1RIwBMg0cahkFsQIB9gQICAwIEgRe5QECpwU/gQX/A50IA0UcnAPkENa8BgTH0gZUrQFGkQEBCAcBCQMLCxoFBhFAhQEDDQcTBhEbOwMLBAwJBhHTAq0FowLNBDHlWAMLGjkBBgYFCRcDCgQOCgQEBQIJAQYGBAQEBAUBBgcDCwYRAwsDCgUJFxAtAgkEDRCLAQE=",
  "mayan-numerals": "GiaAAoHJDhM=",
  "medefaidrin": "GiaAAsG2C1o=",
  "meetei-mayek": "GiaAAtd9AoIXqZQEFsEDLWEJ",
  "mende-kikakui": "GiaAAtiUAemIDsQBjwMP",
  "meroitic-cursive": "GiaAAoGkCBc5Ey0t",
  "meroitic-hieroglyphs": "GiaAAvp+x6QHHw==",
  "meroitic": "GiY0zAGMfm7HpAc3eRMtLQ==",
  "miao": "GiaAAtiUAemkCkqfATiBARA=",
  "modi": "GiaAAtd9AoIXyYkECaG3A0ShAQk=",
  "mongolian": "GicCEQEKJMIBwV0ZQVjBASqXHgIRARMBJjMBsRAT2AXrKAEPB+u4BgEJA79gDA==",
  "mro": "GiaAAsGmCx5BCR0B",
  "multani": "GiaAAokjAYUECbWgCAYQBQMLDiEK",
  "music": "GiaAAtiUAbsCBq+mDfUBgQQmU8EBrwNF",
  "myanmar": "GiaAAsE9nwGXQAKCF8SNBOUCHoECH+GxAxM=",
  "nabataean": "GiaAAsGfCB5PCA==",
  "nag-mundari": "GiaAAuGQDyk=",
  "nandinagari": "GiaAAokjAYUOCYZAEhDtrAQF4cUDBxUtYQo=",
  "new-tai-lue": "GiaAAsFjK2EZQQodAdsYAoIX",
  "newa": "GiaAAi6IdaEIAoIX6bgHW7sBBA==",
  "nko": "GiaAAtgVHgiWAa0FOnsCn2ADgBehIQHFvAYB",
  "nushu": "GiYZAgkJIxlBGX7FfQH8PwT8d6TABZ7HA5+GAosD",
  "nyiakeng-puachue-hmong": "GiaAAsGBDyxhDSEJHQE=",
  "ogham": "GiaAAsFXHA==",
  "ol-chiki": "GiaAAuFuL9IR",
  "ol-onal": "GiaAAokjAdnxDipe",
  "old-hungarian": "GiaAAtp9mgEHAag3IP/4BjKBATJ1BQ==",
  "old-italic": "GiaAAsGJCCNbAg==",
  "old-north-arabian": "GiaAAsGnCB8=",
  "old-permic": "GiaAAi6SCQ0CGuAFsHHiE4n2Bio=",
  "old-persian": "GiaAAoGMCCNRDQ==",
  "old-sogdian": "GiaAAsG5CCc=",
  "old-south-arabian": "GiaAAoGnCB8=",
  "old-turkic": "GiaAAvR+rDeh9wZI",
  "old-uyghur": "GiaAAsAW5JII/REZ",
  "oriya": "GiaAAuMiAScBuwYCCQcVAQkVLwYRAQcEDwgXAQkCFQIPAQcEDxHoRTCzDALcAqYU",
  "osage": "GiaAAsIJBg6aAeiJAcn7BiNRIw==",
  "osmanya": "GiaAAsGPCB1BCQ==",
  "ottoman-siyaq-numbers": "GiaAAsOxDzw=",
  "pahawh-hmong": "GiaAAtd9AoIX6ZQKRaEBCRcGERQ1Eg==",
  "palmyrene": "GiaAAoGfCB8=",
  "pau-cin-hau": "GiaAAsHoCDg=",
  "phags-pa": "GiaAAsNdAgiNIAQ1ARS6FukoAwoFFPPgAzeA1wI=",
  "phoenician": "GiaAAsGhCBs+",
  "psalter-pahlavi": "GiaAAsAWl2cCghfplgcRMwMhBg==",
  "rejang": "GiaAAtd9AoIXyY0EI14=",
  "runic": "GiaAAoFYWA==",
  "samaritan": "GiaAAsEdLWEOgpgB",
  "saurashtra": "GiaAAtd9AoIX6YoERZ0BCw==",
  "sharada": "GiaAAuIijE4EBwEI1wwCghfJiQQFEJGlA18=",
  "shavian": "GiaAAi6zjggv",
  "siddham": "GiaAAtd9AoIX6b4HNXEl",
  "signwriting": "GiaAAsHdDosFtwoEDQ4=",
  "sinhala": "GiaAAokjAbsQAgkRKxczCBQHBhQLBQ4FBx0JGQKAPLMMAoIXq7AHEw==",
  "sogdian": "GiaAAsAWl2cCghfJpQcp",
  "sora-sompeng": "GiYa5gHgfYHDBxhBCQ==",
  "soyombo": "GiaAAtiUAYnSB1I=",
  "sundanese": "GiYa5gHBaz+BBQeXDQIK+BY=",
  "sunuwar": "GiaAAsEJAQYUBjoIn+IIIWEJ",
  "syloti-nagri": "GiaAAokjAYUCCctYAgsBigHuFemIBCw=",
  "symbols2": "GiaAAsF9AQkEDN0OBZEFnwE=",
  "symbols": "Rg4NCSMZQRk9IcZ+9wIDCwLdATNrBhcJPm8KGksBggJXAnkPIwcTBRETswEZNwQyHx1JCBcCCTifAQpBnwGBBeQCzQUDCxw9JE0EDz6FARczDZ8B/wHDBAHAAXxYqwQNJR13JlMfQ2bQAYOHAT/zyAUCjwVOoQEMIGEtoQQbgS4ewZEGE0ETQVbBARjBcithY+EBDiMOIQ4hJF+tAc0DGc8EAhAOBAUMLIQBCgojDCkBCwMsBQINBBUMMgkCCQImGhQOMgUBBgUDDQIOLiZMGgYMBAgTAxwICgkDDwMaBQIJAQwJBAwLAVkMI6sBggOBAS9uDAgGCCoKDwEGFQkbBBsKIQMPBRN29wFeywELICELITeBAQkhJ2EdQQshAYEBC3YWfCSmAS9TwQENIQwhCR83fw4jCiMIIZIBqQJl",
  "syriac": "GicBEQMLAhoGPQKKARYKFpEJAQkBBiwHAhUBBwG4Cx8BCAQ+FworDCChAg0fO30CpwQKsFYEowgENjycB/QOyQIB",
  "tagalog": "GiaAAsFZFT4tAa0jAoIX",
  "tagbanwa": "GiaAAqtaAVcMHQIJAbMiAoIX",
  "tai-le": "GiaAAsEJAQ8BCuk0CaEkHUEEtxoCghfrKAEPAw==",
  "tai-tham": "GiaAAoFmPoEBHD8KIwkhDdcVApwI5g4=",
  "tai-viet": "GiaAAtd9AoIX/4YEAesLQrcBBA==",
  "takri": "GiaAAokjAc9aAoIXyYkECaG5AzmBAQk=",
  "tamil-supplement": "GiaAAsH8CDF+",
  "tamil": "GiaAAokjAb0IAQcFEwIJAw8BBgUBCwELAg0LIQQRAgkDDA4fFMtQAtwCphQ=",
  "tangsa": "GiaAAqGnC06hAQk=",
  "tangut": "GiaAAqG9AQ/+B+L3CUH3L4Fg/wWBFAg=",
  "telugu": "GiaAAuMiAScBuQoMHQIJFjEPJQgVAgkDFwEHAgoHAw0JIwjGQTCzDAKCFw==",
  "thaana": "GicBEQEIBBkBzAHYFR8BCIMBDMEEMZdiBBsBCQHgFszgBhY=",
  "thai": "GiaAArgINlhcoSs5fRyZRwKCFw==",
  "tibetan": "GiaAAsE5R5MBI1EmUSNLDiEM+0ACghf5KAM=",
  "tifinagh": "GiaAAs4IdQEGBQEGNBy1cwJGvBbJHTd/ASA=",
  "tirhuta": "GiaAAuMiAScBoQID/EuzDAKCF8mJBAmhsQNHoQEJ",
  "todhri": "GiaAAsIJBgYUBJYBxYkIMw==",
  "toto": "GiaAArgIqf8OHg==",
  "tulu-tigalari": "GiaAAo0xCZhABPmsBAWCA5+qAwkWBgUlTwkWBgUDCwkXARUB",
  "ugaritic": "GiaAAsGLCB0+",
  "vai": "GiaAAsGRBasC",
  "vietnamese": "GiaAAsUBAR0BMQGBAQFxAR8BowUBBwELATYM721Zlgg=",
  "vithkuqi": "GiaAAqGTCAoZDiEGEQEHChkOIQYRAQ==",
  "wancho": "GiYECwILA18CQARG+X0B4Bbp8w05fg==",
  "warang-citi": "GiYO8gHXfQKCF6nLB1K+AQ==",
  "yezidi": "GiaAAtgVHgiDAQnoAdmeCClXAgsB",
  "yi": "GiaAAs4IIwEGygOZcQEJAT7UB48JE9gF6SgDCgcT5gOLvAOMCaESNuDlAoMEAQ8BCAUBGQEKOAQ9Aw0E",
  "zanabazar-square": "GiaAAtd9AoIX6dAHRw==",
  "znamenny": "GiaAAsG5Di1hFkFz"
};
const readVarint = (buffer, ctx) => {
  let n = 0;
  for (let i = 0; i < 4; i++, ctx.offset++) {
    if (ctx.offset === buffer.length) {
      throw new Error("Truncated buffer");
    }
    const chunk = buffer.charCodeAt(ctx.offset) & 127;
    n |= chunk << i * 7;
    if ((buffer.charCodeAt(ctx.offset) & 128) === 0) {
      ctx.offset++;
      return n >>> 0;
    }
  }
  throw new Error(`Varint at offset ${ctx.offset} exceeds maximum encodable length of 4`);
};
const decodeRanges = function* (rangesBase64) {
  let prev = 0;
  const ranges = atob(rangesBase64);
  const ctx = { offset: 0 };
  while (ctx.offset < ranges.length) {
    const firstEnc = readVarint(ranges, ctx);
    const isRange = !!(firstEnc & 1);
    const first = (firstEnc >>> 1) + prev;
    if (isRange) {
      const second = readVarint(ranges, ctx) + first;
      yield [first, second];
    } else {
      yield first;
    }
    prev = first;
  }
};
const subsetRanges = (subsetName) => decodeRanges(SUBSET_RANGES[subsetName]);
const SUBSET_NAMES = ["adlam", "ahom", "anatolian-hieroglyphs", "arabic", "armenian", "avestan", "balinese", "bamum", "bassa-vah", "batak", "bengali", "bhaiksuki", "brahmi", "braille", "buginese", "buhid", "canadian-aboriginal", "carian", "caucasian-albanian", "chakma", "cham", "cherokee", "chinese-hongkong", "chinese-simplified", "chinese-traditional", "chorasmian", "coptic", "cuneiform", "cypriot", "cypro-minoan", "cyrillic-ext", "cyrillic", "deseret", "devanagari", "dives-akuru", "dogra", "duployan", "egyptian-hieroglyphs", "elbasan", "elymaic", "ethiopic", "garay", "georgian", "glagolitic", "gothic", "grantha", "greek-ext", "greek", "gujarati", "gunjala-gondi", "gurmukhi", "gurung-khema", "hanifi-rohingya", "hanunoo", "hatran", "hebrew", "imperial-aramaic", "indic-siyaq-numbers", "inscriptional-pahlavi", "inscriptional-parthian", "japanese", "javanese", "kaithi", "kana-extended", "kannada", "kawi", "kayah-li", "kharoshthi", "khitan-small-script", "khmer", "khojki", "khudawadi", "kirat-rai", "korean", "lao", "latin-ext", "latin", "lepcha", "limbu", "linear-a", "linear-b", "lisu", "lycian", "lydian", "mahajani", "makasar", "malayalam", "mandaic", "manichaean", "marchen", "masaram-gondi", "math", "mayan-numerals", "medefaidrin", "meetei-mayek", "mende-kikakui", "meroitic-cursive", "meroitic-hieroglyphs", "meroitic", "miao", "modi", "mongolian", "mro", "multani", "music", "myanmar", "nabataean", "nag-mundari", "nandinagari", "new-tai-lue", "newa", "nko", "nushu", "nyiakeng-puachue-hmong", "ogham", "ol-chiki", "ol-onal", "old-hungarian", "old-italic", "old-north-arabian", "old-permic", "old-persian", "old-sogdian", "old-south-arabian", "old-turkic", "old-uyghur", "oriya", "osage", "osmanya", "ottoman-siyaq-numbers", "pahawh-hmong", "palmyrene", "pau-cin-hau", "phags-pa", "phoenician", "psalter-pahlavi", "rejang", "runic", "samaritan", "saurashtra", "sharada", "shavian", "siddham", "signwriting", "sinhala", "sogdian", "sora-sompeng", "soyombo", "sundanese", "sunuwar", "syloti-nagri", "symbols2", "symbols", "syriac", "tagalog", "tagbanwa", "tai-le", "tai-tham", "tai-viet", "takri", "tamil-supplement", "tamil", "tangsa", "tangut", "telugu", "thaana", "thai", "tibetan", "tifinagh", "tirhuta", "todhri", "toto", "tulu-tigalari", "ugaritic", "vai", "vietnamese", "vithkuqi", "wancho", "warang-citi", "yezidi", "yi", "zanabazar-square", "znamenny"];
var AxisValueFormat;
(function(AxisValueFormat2) {
  AxisValueFormat2[AxisValueFormat2["SingleValue"] = 1] = "SingleValue";
  AxisValueFormat2[AxisValueFormat2["Range"] = 2] = "Range";
  AxisValueFormat2[AxisValueFormat2["LinkedValue"] = 3] = "LinkedValue";
  AxisValueFormat2[AxisValueFormat2["MultipleValues"] = 4] = "MultipleValues";
})(AxisValueFormat || (AxisValueFormat = {}));
var AxisValueFlags;
(function(AxisValueFlags2) {
  AxisValueFlags2[AxisValueFlags2["OlderSibling"] = 1] = "OlderSibling";
  AxisValueFlags2[AxisValueFlags2["Elidable"] = 2] = "Elidable";
})(AxisValueFlags || (AxisValueFlags = {}));
const bytesToHex = (bytes) => {
  const arr = bytes instanceof ArrayBuffer ? new Uint8Array(bytes) : bytes;
  let result = "";
  for (let i = 0; i < arr.length; i++) {
    const byte = arr[i];
    if (byte < 16)
      result += "0";
    result += byte.toString(16);
  }
  return result;
};
let hb;
const init = async (wasmUrl) => {
  hb = await createHarfbuzzWrapped(wasmUrl);
  for (const name of SUBSET_NAMES) {
    const set = new hb.HbSet();
    for (const range of subsetRanges(name)) {
      if (typeof range === "number") {
        set.add(range);
      } else {
        set.addRange(range[0], range[1]);
      }
    }
    SUBSET_HB_SETS[name] = set;
  }
  const subsetInput = hb._hb_subset_input_create_or_fail();
  if (subsetInput === 0) {
    throw new Error("Failed to create subset input");
  }
  const defaultLayoutFeatures = new hb.HbSet(hb._hb_subset_input_set(
    subsetInput,
    6
    /* SubsetSets.LAYOUT_FEATURE_TAG */
  ));
  defaultLayoutFeatures.reference();
  for (const featureTag of defaultLayoutFeatures) {
    defaultLayoutFeatureTags.add(tagName(featureTag));
  }
  hb._hb_subset_input_destroy(subsetInput);
};
const decoder = new TextDecoder();
const SUBSET_HB_SETS = {};
const defaultLayoutFeatureTags = /* @__PURE__ */ new Set();
const hashBlob = (data, salt) => {
  return hb.withStack(() => {
    const output = hb.stackAlloc(32);
    hb._blake3_hash_data(data.ptr(), data.length(), output, salt);
    return bytesToHex(hb.HEAPU8.subarray(output, output + 32));
  });
};
class Font {
  hbFace;
  hbFont;
  preprocessedFace = 0;
  _hash = null;
  faceCount;
  faceIndex;
  uid;
  familyName;
  subfamilyName;
  styleValues;
  styleAttributes;
  fileSize;
  /** Variable font axes. Does not include variable axes listed in {@link styleValues}. */
  axes;
  features;
  namedInstances;
  /**
   * Names of Unicode subsets for which this font has *any* coverage (it does not need to cover the entire subset).
   */
  subsetCoverage;
  /**
   * All the Unicode code points contained in the font.
   */
  codePoints;
  static manyFromData(data) {
    const bufs = [];
    for (const arr of data) {
      const blob = new hb.HbBlob(arr);
      const faceCount = hb._hb_face_count(blob.ptr());
      bufs.push({ blob, faceCount });
    }
    const fonts2 = [];
    try {
      for (const { blob, faceCount } of bufs) {
        for (let i = 0; i < faceCount; i++) {
          fonts2.push(new Font(blob, i, faceCount));
        }
      }
    } catch (err) {
      for (; ; ) {
        const font = fonts2.pop();
        if (!font)
          break;
        font.destroy();
      }
      throw err;
    } finally {
      for (const { blob } of bufs) {
        blob.destroy();
      }
    }
    return fonts2;
  }
  constructor(data, index, faceCount) {
    const face = hb._hb_face_create_or_fail(data.ptr(), index);
    if (face === 0) {
      throw new Error("Failed to create hb_face_t");
    }
    this.hbFace = face;
    this.hbFont = hb._hb_font_create(face);
    this.fileSize = data.length();
    this.faceIndex = index;
    this.faceCount = faceCount;
    let uid = this.getOpentypeName(
      3
      /* OtNameId.UNIQUE_ID */
    );
    if (!uid || uid === "") {
      uid = hashBlob(data, index);
    }
    this.uid = uid;
    this.familyName = this.getOpentypeName(
      21
      /* OtNameId.WWS_FAMILY */
    ) || this.getOpentypeName(
      16
      /* OtNameId.TYPOGRAPHIC_FAMILY */
    ) || this.getOpentypeName(
      1
      /* OtNameId.FONT_FAMILY */
    ) || "";
    this.subfamilyName = this.getOpentypeName(
      22
      /* OtNameId.WWS_SUBFAMILY */
    ) || this.getOpentypeName(
      17
      /* OtNameId.TYPOGRAPHIC_SUBFAMILY */
    ) || this.getOpentypeName(
      2
      /* OtNameId.FONT_SUBFAMILY */
    ) || "";
    const { styleValues, axisInfo, namedInstances } = this.getAxisAndStyleInfo();
    this.axes = axisInfo;
    this.styleValues = styleValues;
    this.namedInstances = namedInstances;
    this.styleAttributes = this.parseStatTable() ?? { designAxes: [], axisValues: [] };
    const featureInfo = [];
    const seenTags = /* @__PURE__ */ new Set();
    const featureSet = new hb.HbSet();
    for (const tableTag of [hbTag("GPOS"), hbTag("GSUB")]) {
      featureSet.clear();
      hb._hb_ot_layout_collect_features(face, tableTag, 0, 0, 0, featureSet.ptr());
      for (const featureIndex of featureSet) {
        hb.withStack(() => {
          const featureCountPtr = hb.stackAlloc(4);
          const featureTagsPtr = hb.stackAlloc(4);
          hb.writeUint32(featureCountPtr, 1);
          hb._hb_ot_layout_table_get_feature_tags(face, tableTag, featureIndex, featureCountPtr, featureTagsPtr);
          const featureTag = hb.readUint32(featureTagsPtr);
          if (seenTags.has(featureTag))
            return;
          seenTags.add(featureTag);
          const labelIdPtr = featureCountPtr;
          hb._hb_ot_layout_feature_get_name_ids(face, tableTag, featureIndex, labelIdPtr, 0, 0, 0, 0);
          const labelId = hb.readUint32(labelIdPtr);
          const featureLabel = this.getOpentypeName(labelId);
          const featureTagName = tagName(featureTag);
          featureInfo.push({
            tag: featureTagName,
            label: featureLabel,
            keepByDefault: defaultLayoutFeatureTags.has(featureTagName)
          });
        });
      }
    }
    this.features = featureInfo;
    const subsetCoverage = [];
    const coverageSet = featureSet;
    const faceCodepoints = new hb.HbSet();
    hb._hb_face_collect_unicodes(face, faceCodepoints.ptr());
    for (const subsetName of SUBSET_NAMES) {
      const subsetSet = SUBSET_HB_SETS[subsetName];
      coverageSet.setTo(faceCodepoints);
      for (const codepoint of [0, 13, 32, 160]) {
        coverageSet.del(codepoint);
      }
      coverageSet.intersect(subsetSet);
      let subsetCodepoints = coverageSet.size();
      if (subsetName === "khmer") {
        subsetCodepoints -= SUBSET_HB_SETS.latin.size();
      }
      const coverage = subsetCodepoints / subsetSet.size();
      const THRESHOLD = 0.5;
      const EXT_THRESHOLD = 0.05;
      subsetCoverage.push({
        name: subsetName,
        coverage,
        covered: coverage > (subsetName.endsWith("-ext") ? EXT_THRESHOLD : THRESHOLD)
      });
    }
    this.subsetCoverage = subsetCoverage;
    this.codePoints = faceCodepoints;
    coverageSet.destroy();
  }
  getAxisAndStyleInfo() {
    const face = this.hbFace;
    const styleValues = {};
    return hb.withStack(() => {
      const numAxisInfos = hb._hb_ot_var_get_axis_count(face);
      const axisInfoSize = 32;
      const axisInfo = [];
      const axisTags = [];
      const axisInfosRaw = hb.malloc(numAxisInfos * axisInfoSize);
      try {
        const numToFetch = hb.stackAlloc(4);
        hb.writeUint32(numToFetch, numAxisInfos);
        hb._hb_ot_var_get_axis_infos(face, 0, numToFetch, axisInfosRaw);
        for (let i = axisInfosRaw; i < axisInfosRaw + axisInfoSize * numAxisInfos; i += axisInfoSize) {
          const tag = tagName(hb.readUint32(i + 4));
          const nameId = hb.readUint32(i + 8);
          const min = hb.readFloat32(i + 16);
          const defaultValue = hb.readFloat32(i + 20);
          const max = hb.readFloat32(i + 24);
          switch (tag) {
            case "wght": {
              styleValues.weight = { type: "variable", value: { min, defaultValue, max } };
              break;
            }
            case "wdth": {
              styleValues.width = { type: "variable", value: { min, defaultValue, max } };
              break;
            }
            case "ital": {
              styleValues.italic = { type: "variable", value: { min, defaultValue, max } };
              break;
            }
            case "slnt": {
              styleValues.slant = { type: "variable", value: { min, defaultValue, max } };
              break;
            }
            default: {
              const name = this.getOpentypeName(nameId);
              axisInfo.push({
                tag,
                name,
                min,
                defaultValue,
                max
              });
            }
          }
          axisTags.push(tag);
        }
        if (!Object.prototype.hasOwnProperty.call(styleValues, "weight")) {
          styleValues.weight = {
            type: "single",
            value: hb._hb_style_get_value(this.hbFont, hbTag("wght"))
          };
        }
        if (!Object.prototype.hasOwnProperty.call(styleValues, "width")) {
          styleValues.width = {
            type: "single",
            value: hb._hb_style_get_value(this.hbFont, hbTag("wdth"))
          };
        }
        if (!Object.prototype.hasOwnProperty.call(styleValues, "italic")) {
          styleValues.italic = {
            type: "single",
            value: hb._hb_style_get_value(this.hbFont, hbTag("ital"))
          };
        }
        if (!Object.prototype.hasOwnProperty.call(styleValues, "slant")) {
          styleValues.slant = {
            type: "single",
            value: hb._hb_style_get_value(this.hbFont, hbTag("slnt"))
          };
        }
      } finally {
        hb._free(axisInfosRaw);
      }
      const numNamedInstances = hb._hb_ot_var_get_named_instance_count(face);
      const namedInstances = [];
      const coordsPtr = hb.malloc(4 * numAxisInfos);
      try {
        for (let i = 0; i < numNamedInstances; i++) {
          const subfamilyNameId = hb._hb_ot_var_named_instance_get_subfamily_name_id(face, i);
          const postscriptNameId = hb._hb_ot_var_named_instance_get_postscript_name_id(face, i);
          const subfamilyName = this.getOpentypeName(subfamilyNameId);
          const postscriptName = this.getOpentypeName(postscriptNameId);
          hb.withStack(() => {
            const numCoordsPtr = hb.stackAlloc(4);
            hb.writeUint32(numCoordsPtr, numAxisInfos);
            hb._hb_ot_var_named_instance_get_design_coords(face, i, numCoordsPtr, coordsPtr);
            const numCoords = hb.readUint32(numCoordsPtr);
            const coords = {};
            for (let i2 = 0; i2 < numCoords; i2++) {
              const value = hb.readFloat32(coordsPtr + (i2 << 2));
              coords[axisTags[i2]] = value;
            }
            namedInstances.push({
              subfamilyName,
              postscriptName,
              coords
            });
          });
        }
      } finally {
        hb._free(coordsPtr);
      }
      return {
        styleValues,
        axisInfo,
        namedInstances
      };
    });
  }
  /**
   * Fetch a name string from an OpenType font by ID.
   * @param id The ID of the name to fetch. Can be `HB_OT_NAME_ID_INVALID`.
   * @returns The name string, or null if it doesn't exist or is `HB_OT_NAME_ID_INVALID`.
   */
  getOpentypeName(id) {
    if (id === 65535) {
      return null;
    }
    const face = this.hbFace;
    return hb.withStack(() => {
      const nameSizePtr = hb.stackAlloc(4);
      const dummyNamePtr = hb.stackAlloc(1);
      hb.writeUint32(nameSizePtr, 1);
      let nameSize = hb._hb_ot_name_get_utf8(face, id, 0, nameSizePtr, dummyNamePtr);
      if (nameSize === 0) {
        return null;
      }
      const namePtr = hb.malloc(nameSize + 1);
      try {
        hb.writeUint32(nameSizePtr, nameSize + 1);
        hb._hb_ot_name_get_utf8(face, id, 0, nameSizePtr, namePtr);
        nameSize = hb.readUint32(nameSizePtr);
        const fontFamilyName = decoder.decode(hb.HEAPU8.subarray(namePtr, namePtr + nameSize));
        return fontFamilyName;
      } finally {
        hb._free(namePtr);
      }
    });
  }
  parseStatTable() {
    const ptr = hb._hb_face_reference_table(this.hbFace, hbTag("STAT"));
    if (!ptr)
      return null;
    const statBlob = new hb.HbBlob(ptr);
    try {
      const stat = statBlob.data();
      let offset = stat;
      const readU16 = () => {
        const result = hb.memoryView.getUint16(offset);
        offset += 2;
        return result;
      };
      const readU32 = () => {
        const result = hb.memoryView.getUint32(offset);
        offset += 4;
        return result;
      };
      const readFixed = () => {
        const result = hb.memoryView.getInt32(offset) / 65536;
        offset += 4;
        return result;
      };
      const seek = (to) => {
        offset = stat + to;
      };
      const __majorVersion = readU16();
      const __minorVersion = readU16();
      const designAxisSize = readU16();
      const designAxisCount = readU16();
      const designAxesOffset = readU32();
      const axisValueCount = readU16();
      const offsetToAxisValueOffsets = readU32();
      const designAxes = [];
      for (let i = 0; i < designAxisCount; i++) {
        seek(designAxesOffset + i * designAxisSize);
        const tag = tagName(readU32());
        const axisNameID = readU16();
        const ordering = readU16();
        const name = this.getOpentypeName(axisNameID);
        designAxes.push({ tag, name, ordering });
      }
      const axisValues = [];
      for (let i = 0; i < axisValueCount; i++) {
        seek(offsetToAxisValueOffsets + i * 2);
        const axisValueOffset = readU16();
        seek(offsetToAxisValueOffsets + axisValueOffset);
        const format = readU16();
        const axisIndexOrCount = readU16();
        const flags = readU16();
        const nameID = readU16();
        const name = this.getOpentypeName(nameID);
        const axisValue = { flags, name };
        switch (format) {
          case 1: {
            const value = readFixed();
            axisValues.push(Object.assign(axisValue, {
              format,
              axisIndex: axisIndexOrCount,
              value
            }));
            break;
          }
          case 2: {
            const nominalValue = readFixed();
            let min = readFixed();
            let max = readFixed();
            if (min === -32768)
              min = -Infinity;
            if (max === 32767.99998474121)
              max = Infinity;
            axisValues.push(Object.assign(axisValue, {
              format,
              axisIndex: axisIndexOrCount,
              nominalValue,
              min,
              max
            }));
            break;
          }
          case 3: {
            const value = readFixed();
            const linkedValue = readFixed();
            axisValues.push(Object.assign(axisValue, {
              format,
              axisIndex: axisIndexOrCount,
              value,
              linkedValue
            }));
            break;
          }
          case 4: {
            const values = [];
            for (let j = 0; j < axisIndexOrCount; j++) {
              values.push({ axisIndex: readU16(), value: readFixed() });
            }
            axisValues.push(Object.assign(axisValue, {
              format,
              axisCount: axisIndexOrCount,
              axisValues: values
            }));
            break;
          }
        }
      }
      return { designAxes, axisValues };
    } finally {
      statBlob.destroy();
    }
  }
  destroy() {
    if (this.preprocessedFace !== 0)
      hb._hb_face_destroy(this.preprocessedFace);
    hb._hb_font_destroy(this.hbFont);
    hb._hb_face_destroy(this.hbFace);
    this.codePoints.destroy();
  }
  subset(settings) {
    const subsetInput = hb._hb_subset_input_create_or_fail();
    if (subsetInput === 0) {
      throw new Error("Failed to create subset input");
    }
    let inputFace;
    if (settings.preprocess) {
      if (this.preprocessedFace === 0) {
        this.preprocessedFace = hb._hb_subset_preprocess(this.hbFace);
      }
      inputFace = this.preprocessedFace;
    } else {
      inputFace = this.hbFace;
    }
    try {
      const unicodeSet = new hb.HbSet(hb._hb_subset_input_unicode_set(subsetInput));
      unicodeSet.clear();
      if (settings.unicodeRanges === "all") {
        unicodeSet.invert();
      } else {
        for (const namedSubset of settings.unicodeRanges.named) {
          unicodeSet.union(SUBSET_HB_SETS[namedSubset]);
        }
        for (const rangeOrSingle of settings.unicodeRanges.custom) {
          if (typeof rangeOrSingle === "number") {
            unicodeSet.add(rangeOrSingle);
          } else {
            unicodeSet.addRange(rangeOrSingle[0], rangeOrSingle[1]);
          }
        }
      }
      if (settings.features) {
        const featuresSet = new hb.HbSet(hb._hb_subset_input_set(
          subsetInput,
          6
          /* SubsetSets.LAYOUT_FEATURE_TAG */
        ));
        for (const [featureTag, enable] of Object.entries(settings.features)) {
          if (enable) {
            featuresSet.add(hbTag(featureTag));
          } else {
            featuresSet.del(hbTag(featureTag));
          }
        }
      }
      if (settings.dropTables) {
        const dropTablesSet = new hb.HbSet(hb._hb_subset_input_set(
          subsetInput,
          3
          /* SubsetSets.DROP_TABLE_TAG */
        ));
        for (const tableTag of settings.dropTables) {
          dropTablesSet.add(hbTag(tableTag));
        }
      }
      for (const axisSetting of settings.axisValues) {
        switch (axisSetting.type) {
          case "single": {
            hb._hb_subset_input_pin_axis_location(subsetInput, inputFace, hbTag(axisSetting.tag), axisSetting.value);
            break;
          }
          case "variable": {
            hb._hb_subset_input_set_axis_range(subsetInput, inputFace, hbTag(axisSetting.tag), axisSetting.value.min, axisSetting.value.max, axisSetting.value.defaultValue ?? NaN);
          }
        }
      }
      const subsetFace = hb._hb_subset_or_fail(inputFace, subsetInput);
      if (subsetFace === 0) {
        throw new Error(`Failed to subset ${this.familyName} ${this.subfamilyName}`);
      }
      const faceBlob = hb._hb_face_reference_blob(subsetFace);
      hb._hb_face_destroy(subsetFace);
      const faceBlobObject = new hb.HbBlob(faceBlob);
      const data = faceBlobObject.copyAsArray();
      faceBlobObject.destroy();
      const styleValues = {
        weight: settings.axisValues.find((v) => v.tag === "wght") ?? this.styleValues.weight,
        width: settings.axisValues.find((v) => v.tag === "wdth") ?? this.styleValues.width,
        italic: settings.axisValues.find((v) => v.tag === "ital") ?? this.styleValues.italic,
        slant: settings.axisValues.find((v) => v.tag === "slnt") ?? this.styleValues.slant
      };
      for (const styleKey of ["weight", "width", "italic", "slant"]) {
        const styleValue = styleValues[styleKey];
        if (styleValue.type === "variable" && !styleValue.value.defaultValue) {
          styleValues[styleKey] = {
            type: "variable",
            value: {
              min: styleValue.value.min,
              max: styleValue.value.max,
              defaultValue: this.styleValues[styleKey].value.defaultValue
            }
          };
        }
      }
      const axes = [];
      for (const axis of this.axes) {
        const axisSetting = settings.axisValues.find((v) => v.tag === axis.tag);
        if (!axisSetting)
          continue;
        if (axisSetting.type === "variable") {
          axes.push({
            tag: axis.tag,
            name: axis.name,
            type: "variable",
            value: {
              min: axisSetting.value.min,
              max: axisSetting.value.max,
              defaultValue: axisSetting.value.defaultValue ?? axis.defaultValue
            }
          });
        } else {
          axes.push({
            tag: axis.tag,
            name: axis.name,
            type: "single",
            value: axisSetting.value
          });
        }
      }
      let subsetNamedInstance = null;
      if (this.namedInstances) {
        const variationCoords = {};
        for (const axisSetting of settings.axisValues) {
          if (axisSetting.type === "single") {
            variationCoords[axisSetting.tag] = axisSetting.value;
          }
        }
        outer: for (const namedInstance of this.namedInstances) {
          for (const [tag2, value] of Object.entries(namedInstance.coords)) {
            if (variationCoords[tag2] !== value) {
              continue outer;
            }
          }
          subsetNamedInstance = namedInstance;
          break;
        }
      }
      const styleAttributes = {
        designAxes: [],
        axisValues: []
      };
      for (const axis of this.styleAttributes.designAxes) {
        styleAttributes.designAxes.push(Object.assign({}, axis));
      }
      const axisSettingsByTag = /* @__PURE__ */ new Map();
      for (const axisSetting of settings.axisValues) {
        axisSettingsByTag.set(axisSetting.tag, axisSetting);
      }
      const axisValueOutsideRange = (tag2, value) => {
        const axisSetting = axisSettingsByTag.get(tag2);
        if (!axisSetting)
          return false;
        if (axisSetting.type === "single")
          return value !== axisSetting.value;
        return value < axisSetting.value.min || value > axisSetting.value.max;
      };
      for (const axisValue of this.styleAttributes.axisValues) {
        switch (axisValue.format) {
          case AxisValueFormat.SingleValue: {
            const tag2 = styleAttributes.designAxes[axisValue.axisIndex].tag;
            if (!axisValueOutsideRange(tag2, axisValue.value))
              styleAttributes.axisValues.push(axisValue);
            break;
          }
          case AxisValueFormat.Range: {
            const tag2 = styleAttributes.designAxes[axisValue.axisIndex].tag;
            if (!axisValueOutsideRange(tag2, axisValue.nominalValue)) {
              styleAttributes.axisValues.push(axisValue);
            }
            break;
          }
          case AxisValueFormat.LinkedValue: {
            const tag2 = styleAttributes.designAxes[axisValue.axisIndex].tag;
            if (!axisValueOutsideRange(tag2, axisValue.value))
              styleAttributes.axisValues.push(axisValue);
            break;
          }
          case AxisValueFormat.MultipleValues: {
            for (const subValue of axisValue.axisValues) {
              const tag2 = styleAttributes.designAxes[subValue.axisIndex].tag;
              if (!axisValueOutsideRange(tag2, subValue.value)) {
                styleAttributes.axisValues.push(axisValue);
                break;
              }
            }
            break;
          }
        }
      }
      const subsetCodepoints = new hb.HbSet();
      subsetCodepoints.setTo(this.codePoints);
      subsetCodepoints.intersect(unicodeSet);
      const unicodeRanges = Array.from(subsetCodepoints.iterRanges());
      subsetCodepoints.destroy();
      const tag = data[3] | data[2] << 8 | data[1] << 16 | data[0] << 24;
      return {
        familyName: this.familyName,
        subfamilyName: this.subfamilyName,
        format: tag === hbTag("OTTO") ? "opentype" : "truetype",
        data,
        styleValues,
        styleAttributes,
        axes,
        namedInstance: subsetNamedInstance,
        unicodeRanges
      };
    } finally {
      hb._hb_subset_input_destroy(subsetInput);
    }
  }
  /**
   * Get the TTF data for this font. This is a copy of the data, not a reference to the original. If this is part of a
   * TTC, this will create a new TTF file containing only this face from it. This returns a new Uint8Array every time,
   * so the result can be transferred.
   */
  getData() {
    if (this.faceCount > 1) {
      const builderFace = hb._hb_face_builder_create();
      const referencedTables = [];
      try {
        hb.withStack(() => {
          const tableCountPtr = hb.stackAlloc(4);
          const tableCount = hb._hb_face_get_table_tags(this.hbFace, 0, 0, 0);
          if (tableCount === 0)
            throw new Error("Could not get font table count");
          const tableTags = hb.malloc(tableCount * 4);
          hb.writeUint32(tableCountPtr, tableCount);
          hb._hb_face_get_table_tags(this.hbFace, 0, tableCountPtr, tableTags);
          const fetchedTableCount = hb.readUint32(tableCountPtr);
          for (let i = 0; i < fetchedTableCount; i++) {
            const tag = hb.readUint32(tableTags + i * 4);
            const tableBlob = hb._hb_face_reference_table(this.hbFace, tag);
            referencedTables.push(tableBlob);
            if (!hb._hb_face_builder_add_table(builderFace, tag, tableBlob)) {
              throw new Error(`Could not add table ${tagName(tag)}`);
            }
          }
        });
        const faceBlob = hb._hb_face_reference_blob(builderFace);
        const blob = new hb.HbBlob(faceBlob);
        try {
          const data = blob.copyAsArray();
          return data;
        } finally {
          blob.destroy();
        }
      } finally {
        for (const blob of referencedTables) {
          hb._hb_blob_destroy(blob);
        }
        hb._hb_face_destroy(builderFace);
      }
    } else {
      return this.getFileData();
    }
  }
  /**
   * Get the full file data for this font. This is a copy of the data, not a reference to the original. If this is
   * part of a TTC, this will return the *entire* contents of the TTC, unlike {@link getData}.
   */
  getFileData() {
    const faceBlob = hb._hb_face_reference_blob(this.hbFace);
    const blob = new hb.HbBlob(faceBlob);
    try {
      const data = blob.copyAsArray();
      return data;
    } finally {
      blob.destroy();
    }
  }
  /**
   * Get a hash for the full file data backing this font (e.g. for caching purposes). This is calculated once lazily.
   * If this font is part of a TTC, the hash will be for the *entire* file contents.
   */
  getFileHash() {
    if (this._hash !== null)
      return this._hash;
    const faceBlob = hb._hb_face_reference_blob(this.hbFace);
    const blob = new hb.HbBlob(faceBlob);
    try {
      this._hash = hashBlob(blob, 0);
      return this._hash;
    } finally {
      blob.destroy();
    }
  }
  static getSfntVersion(data) {
    const tag = data[3] | data[2] << 8 | data[1] << 16 | data[0] << 24;
    return tag === hbTag("OTTO") ? "opentype" : "truetype";
  }
}
const initPromise = init(new URL("/assets/hb-CPUyzAJX.wasm", import.meta.url).href);
const listener = async (event) => {
  const message = event.data;
  try {
    switch (message.type) {
      case "update-fonts": {
        postMessageFromWorker({
          type: "updated-fonts",
          message: await updateFonts(message.message.loadFonts, message.message.unloadFonts),
          originId: message.id
        });
        break;
      }
      case "subset-font": {
        const { subsettedFont, transfer } = subsetFont(message.message.font, message.message.settings);
        postMessageFromWorker({
          type: "subsetted-font",
          message: subsettedFont,
          originId: message.id
        }, transfer);
        break;
      }
      case "get-font-data": {
        const font = getFont(message.message);
        const data = font.getData();
        const format = Font.getSfntVersion(data);
        postMessageFromWorker({
          type: "got-font-data",
          message: { data, format },
          originId: message.id
        }, [data]);
        break;
      }
      case "get-font-file-data": {
        const font = getFont(message.message);
        const data = font.getFileData();
        postMessageFromWorker({
          type: "got-font-file-data",
          message: data,
          originId: message.id
        }, [data]);
        break;
      }
      case "get-font-file-hash": {
        const font = getFont(message.message);
        const hash = font.getFileHash();
        postMessageFromWorker({
          type: "got-font-file-hash",
          message: hash,
          originId: message.id
        });
        break;
      }
      case "close": {
        removeEventListener("message", listener);
      }
    }
  } catch (error) {
    postMessage({
      type: "error",
      message: error,
      originId: message.id
    });
  }
};
addEventListener("message", listener);
let fontRefId = 0;
const fonts = /* @__PURE__ */ new Map();
const getFont = (id) => {
  const font = fonts.get(id);
  if (!font) {
    throw new Error(`No font with ID ${id}`);
  }
  return font;
};
const updateFonts = async (loadFonts, unloadFonts) => {
  await initPromise;
  for (const oldFont of unloadFonts) {
    const font = fonts.get(oldFont);
    if (!font)
      continue;
    font.destroy();
    fonts.delete(oldFont);
  }
  const newFonts = Font.manyFromData(loadFonts);
  const newFontRefs = [];
  for (const newFont of newFonts) {
    const newFontRef = {
      id: fontRefId++,
      uid: newFont.uid,
      faceCount: newFont.faceCount,
      faceIndex: newFont.faceIndex,
      familyName: newFont.familyName,
      subfamilyName: newFont.subfamilyName,
      styleValues: newFont.styleValues,
      styleAttributes: newFont.styleAttributes,
      fileSize: newFont.fileSize,
      axes: newFont.axes,
      features: newFont.features,
      namedInstances: newFont.namedInstances,
      subsetCoverage: newFont.subsetCoverage,
      unicodeRanges: Array.from(newFont.codePoints.iterRanges())
    };
    newFontRefs.push(newFontRef);
    fonts.set(newFontRef.id, newFont);
  }
  return { fonts: newFontRefs };
};
const subsetFont = (fontId, settings) => {
  const font = fonts.get(fontId);
  if (!font) {
    throw new Error(`No font with ID ${font}`);
  }
  const subsettedFont = font.subset(settings);
  return { subsettedFont, transfer: [subsettedFont.data.buffer] };
};
