(function(){"use strict";const g=async r=>{let t,e;if(typeof r=="string")try{t=new URL(r)}catch{e=r}else t=r;if(t)try{t.protocol==="file:"&&(e=(await Promise.resolve().then(function(){return p})).fileURLToPath(t))}catch{}if(e)try{const o=await(await Promise.resolve().then(function(){return p})).readFile(e);return new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}catch{}if(!t)throw new Error(`Your runtime does not support any loading strategy for ${r}.`);return new Uint8Array(await(await fetch(t)).arrayBuffer())},h=async(r,t)=>{if(typeof r=="object"&&"byteLength"in r)return await WebAssembly.instantiate(r,t);if("instantiateStreaming"in WebAssembly){const e=typeof r=="string"?new URL(r):r;if(e.protocol!=="file:"){const o=await fetch(e);return await WebAssembly.instantiateStreaming(o,t)}}return await WebAssembly.instantiate(await g(r),t)},u=async r=>{const t=()=>{throw new Error("Not implemented")};let e;const o={fd_seek:t,fd_write:t,fd_close:t,proc_exit:t,emscripten_notify_memory_growth:()=>{e=new DataView(s.exports.memory.buffer),w.HEAPU8=new Uint8Array(s.exports.memory.buffer)}},i={env:o,wasi_snapshot_preview1:o},{module:n,instance:s}=await h(r,i);e=new DataView(s.exports.memory.buffer);const l=s.exports.__indirect_function_table,w={wasmMemory:s.exports.memory,HEAPU8:new Uint8Array(s.exports.memory.buffer),stackAlloc:s.exports._emscripten_stack_alloc,stackRestore:s.exports._emscripten_stack_restore,stackSave:s.exports.emscripten_stack_get_current,addIndirectFunction(a){const c=l.grow(1);return l.set(c,a),c},withStack(a){const c=s.exports.emscripten_stack_get_current();try{return a()}finally{s.exports._emscripten_stack_restore(c)}},readUint32(a){return e.getUint32(a,!0)},writeUint32(a,c){e.setUint32(a,c,!0)},readFloat32(a){return e.getFloat32(a,!0)},writeFloat32(a,c){e.setFloat32(a,c,!0)},malloc(a){const c=s.exports.malloc(a);if(c===0)throw new Error("Out of WASM memory");return c}};for(const a of WebAssembly.Module.exports(n))switch(a.name){case"memory":case"_emscripten_stack_alloc":case"_emscripten_stack_restore":case"emscripten_stack_get_current":case"malloc":case"__indirect_function_table":case"_initialize":continue;default:w[`_${a.name}`]=s.exports[a.name];break}return s.exports._initialize(),w},d=(r,t=[])=>{try{postMessage(r,void 0,t)}catch(e){postMessage({type:"error",message:e,originId:r.originId})}};let f=null,m=null;const _=async r=>{const t=r.data;try{switch(t.type){case"init-woff-wasm":{f=u(t.message.woff1),m=u(t.message.woff2);break}case"compress-font":{let e;switch(t.message.algorithm){case"woff":e=await b(t.message.data,t.message.quality);break;case"woff2":e=await E(t.message.data,t.message.quality);break}d({type:"compressed-font",message:e,originId:t.id},[e.buffer]);break}case"decompress-font":{let e;switch(t.message.algorithm){case"woff":e=await k(t.message.data);break;case"woff2":e=await F(t.message.data);break}d({type:"decompressed-font",message:e,originId:t.id},[e.buffer]);break}case"close":removeEventListener("message",_)}}catch(e){postMessage({type:"error",message:e,originId:t.id})}};addEventListener("message",_);const y=["","Out of memory","Invalid input file","Compression failure","Bad signature","Buffer too small","Bad parameter","Improperly ordered chunks"],b=async(r,t)=>{if(!f)throw new Error("WOFF1 module not initialized");const e=await f,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{return e.withStack(()=>{const i=e.stackAlloc(4),n=e.stackAlloc(4),s=e._woffEncode(o,r.byteLength,0,0,t,i,n);if(!s)throw new Error("Failed to convert TTF to WOFF");const l=e.readUint32(n);if((l&255)!==0)throw new Error(`Failed to convert TTF to WOFF: ${y[l]}`);const w=e.HEAPU8.slice(s,s+e.readUint32(i));return e._free(s),w})}finally{e._free(o)}},k=async r=>{if(!f)throw new Error("WOFF1 module not initialized");const t=await f,e=t.malloc(r.byteLength);t.HEAPU8.set(r,e);try{return t.withStack(()=>{const o=t.stackAlloc(4),i=t.stackAlloc(4),n=t._woffDecode(e,r.byteLength,o,i);if(!n)throw new Error("Failed to convert WOFF to TTF");const s=t.readUint32(i);if((s&255)!==0)throw new Error(`Failed to convert WOFF to TTF: ${y[s]}`);const l=t.HEAPU8.slice(n,n+t.readUint32(o));return t._free(n),l})}finally{t._free(e)}},E=async(r,t)=>{if(!m)throw new Error("WOFF2 module not initialized");const e=await m,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{const i=e._max_woff2_compressed_size(o,r.byteLength),n=e.malloc(i);try{return e.withStack(()=>{const s=e.stackAlloc(4);if(e.writeUint32(s,i),!!!e._convert_ttf_to_woff2(o,r.byteLength,n,s,t))throw new Error("Failed to convert TTF to WOFF2");return e.HEAPU8.slice(n,n+e.readUint32(s))})}finally{e._free(n)}}finally{e._free(o)}},F=async r=>{if(!m)throw new Error("WOFF2 module not initialized");const e=await m,o=e.malloc(r.byteLength);e.HEAPU8.set(r,o);try{const i=e._compute_woff2_final_size(o,r.byteLength);let n=e.malloc(i);try{return e.withStack(()=>{const s=e.stackAlloc(4);return n=e._convert_woff2_to_ttf(o,r.byteLength,s,62914560),e.HEAPU8.slice(n,n+e.readUint32(s))})}finally{e._free(n)}}finally{e._free(o)}};var p=Object.freeze({__proto__:null})})();
